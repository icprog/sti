/*! \file
 *  \author Jonathan David Harvey
 *  \author Jason Michael Hogan
 *  \author David Marvin Slaughter Johnson
 *  \author Olaf Mandel
 *  \brief Interface Definition of the Client-Server CORBA communication.
 *  \section license License
 *
 *  Copyright (C) 2008 Jonathan Harvey <harv@stanford.edu>\n
 *  Copyright (C) 2008 Jason Hogan <hogan@stanford.edu>\n
 *  Copyright (C) 2008 David Johnson <dmsj@stanford.edu>\n
 *  Copyright (C) 2008 Olaf Mandel <mandel@stanford.edu>\n
 *  This file is part of Stanford Timing Interface (STI).
 *
 *  STI is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  STI is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with STI.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef CLIENT_IDL
#define CLIENT_IDL

#include "device.idl"

module STI_Client_Server
{
    struct TOverwritten {
        string name;
        string value;
    };

    struct TChannel {
        STI_Server_Device::TDevice         device;
        unsigned short channel;

        STI_Server_Device::TChannelType    type;
        // Types that this channel expects
        STI_Server_Device::TData            inputType;
        STI_Server_Device::TValue            outputType;
    };
    

	union TVarMixed;

	typedef sequence<TVarMixed> TVarMixedSeq;

    enum TType {TypeNumber, TypeString, TypeChannel, TypeList, TypeObject};

    union TVarMixed switch(TType) {
        case TypeNumber : double         number;
        case TypeString : string         stringVal;
        case TypeChannel: unsigned short channel;   //References parser.channels
		case TypeList   : TVarMixedSeq   list;
        case TypeObject : string         objectVal;
    };

    struct TPosition {
        unsigned short file;  //References parser.files
        unsigned long  line;
    };

    struct TVariable {
        string    name;
        TVarMixed value;
        TPosition pos;
    };

    struct TDDS {
        double freq;
        double phase;
        double ampl;
    };


    //union TValMixed switch(STI_Server_Device::TValue) {
    //    case STI_Server_Device::ValueNumber    : double number;
    //    case STI_Server_Device::ValueString    : string stringVal;
    //    case STI_Server_Device::ValueDDSTriplet: TDDS   triplet;
    //    case STI_Server_Device::ValueMeas      : boolean meas;  //No data to find here
    //};

    struct TEvent {
        unsigned short channel;   //References Parser.channels
        double         time;
		STI_Server_Device::TValMixed      value;
        TPosition      pos;
    };

	interface ModeInterrupt
	{
		void requestControl(in string myName, in string ipAddress);
		void controlTakenBy(in string myName, in string ipAddress);
	};

    interface ModeHandler
    {
		readonly attribute string controllerName;
		readonly attribute string controllerIP;

		boolean requestControl(in string myName, in string ipAddress, in ModeInterrupt interrupt);
		boolean takeControl(in string myName, in string ipAddress, in ModeInterrupt interrupt);
		void cancelRequest();

        void answerRequest(in boolean yield);
    };


    typedef sequence<TOverwritten> TOverwrittenSeq;
    typedef sequence<TChannel>     TChannelSeq;
    typedef sequence<string>       TStringSeq;
    typedef sequence<TVariable>    TVariableSeq;
    typedef sequence<TEvent>       TEventSeq;

	interface Messenger
	{
		void sendMessage(in string message);
	};

    interface Parser
    {
        //Set this before parsing
        attribute TOverwrittenSeq overwritten;
        attribute boolean         lockOnParse;	//make timing file readonly

        //Parse with one of these
                //Both return true on error
        boolean parseFile(in string filename, in Messenger parserCallback);
        boolean parseString(in string code);
		boolean parseLoopScript(in string script);		//for generating the ExpSequence from a script

        //Harvest the parsing result here:
        readonly attribute string       outMsg;
        readonly attribute string       errMsg;
        readonly attribute string       mainFile;
        readonly attribute TChannelSeq  channels;
        readonly attribute TStringSeq   files;
        readonly attribute TVariableSeq variables;
        readonly attribute TEventSeq    events;
    };

    enum TStatusLevel {LevelStopped, LevelRunning, LevelPaused, LevelError };

    struct TStatus {
        TStatusLevel   level;
        double         curTime;
        unsigned long  curEvent;
        unsigned short curCycle;
    };

    struct TRow {
        TStringSeq val;
        boolean    done;
    };

    typedef sequence<TRow> TRowSeq;

    interface ExpSequence
    {

		boolean setExpSequence(in TStringSeq Variables, in TRowSeq Experiments);

        attribute TStringSeq       variables; //ColumnHeaders
        readonly attribute TRowSeq experiments;
        

                //All return true on error
        boolean appendRow(in TStringSeq newRow);
        boolean moveRow(in unsigned long oldPos, in unsigned long newPos);
        boolean editRow(in unsigned long pos, in TRow newRow);
		boolean deleteRow(in unsigned long pos);
		void clear();


        void editRowDone(in unsigned long pos, in boolean newDone);
    };

    interface Control
    {
        //Is it valid to call methods on the readonly expSeq ???
        //Not needed; client has access to a single global instances of interfaces
//        readonly attribute ExpSequence expSeq;
		

        readonly attribute string errMsg;
        TStatus status();

		string transferErr(in string deviceID);

        void reset();
        void setDirect();   //Dataformat unknown!
        void runSingle();   //Uses Parser.overwritten as it currently is.
        void runSequence(); //Sets Parser.overwritten from ExpSequence
        void continue();    //Jumps to next entry in expSeq
        void stop();
    };

    struct TAttribute {
        string key;
        string value;
        TStringSeq values;
    };

    typedef sequence<TAttribute> TAttributeSeq;
    typedef sequence<STI_Server_Device::TDevice> TDeviceSeq;


    interface DeviceConfigure
    {
        readonly attribute TDeviceSeq devices;

        TAttributeSeq getDeviceAttributes(in string deviceID);
        boolean setDeviceAttribute(in string deviceID, in string key, in string value);

        TChannelSeq getDeviceChannels(in string deviceID);

        boolean deviceStatus(in string deviceID);
    };

	interface StreamingDataTransfer
	{
		STI_Server_Device::TMeasurementSeq getStreamingData(
                                         in string         deviceID, 
                                         in unsigned short channel,
                                         in double         initial_t, 
                                         in double         final_t, 
                                         in double         delta_t);

		STI_Server_Device::TMeasurementSeq getMeasurements(in string deviceID);
		
		string getErrMsg(in string deviceID);
	};

	interface ServerCommandLine
	{
		string deviceCmdName(in string deviceID);
		string executeArgs(in string deviceID, in string args);

		TStringSeq registeredPartners(in string deviceID);
		TStringSeq requiredPartners(in string deviceID);
	};

};

#endif
