/*! \file
 *  \author Jonathan David Harvey
 *  \author Jason Michael Hogan
 *  \author David Marvin Slaughter Johnson
 *  \author Olaf Mandel
 *  \brief Interface Definition of the Server-Device CORBA communication.
 *  \section license License
 *
 *  Copyright (C) 2008 Jonathan Harvey <harv@stanford.edu>\n
 *  Copyright (C) 2008 Jason Hogan <hogan@stanford.edu>\n
 *  Copyright (C) 2008 David Johnson <dmsj@stanford.edu>\n
 *  Copyright (C) 2008 Olaf Mandel <mandel@stanford.edu>\n
 *  This file is part of Stanford Timing Interface (STI).
 *
 *  STI is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  STI is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with STI.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef DEVICE_IDL
#define DEVICE_IDL

module STI_Server_Device
{
    typedef sequence<string> TStringSeq;
    
    struct TAttribute {
        string key;
        string value;
        TStringSeq values;
    };

    typedef sequence<TAttribute> TAttributeSeq;

    // DeviceServer and Device object.
    interface Configure
    {
        // Configurable attributes presented by this device to the server
        readonly attribute TAttributeSeq attributes;
        readonly attribute string deviceName;

        boolean setAttribute(in string key, in string value);
        string getAttribute(in string key);
    };

    struct TDDS {
        double freq;
        double phase;
        double ampl;
    };

    enum TValue {ValueNumber, ValueString, ValueDDSTriplet, ValueMeas};

    union TValMixed switch(TValue) {
        case ValueNumber    : double  number;
        case ValueString    : string  stringVal;
        case ValueDDSTriplet: TDDS    triplet;
        case ValueMeas      : boolean meas;  //No data to find here
    };

    struct TDeviceEvent {
        unsigned short channel;   //== STI_Client_Server::TChannel.channel
        double         time;
        TValMixed      value;
    };

    typedef sequence<TDeviceEvent>  TDeviceEventSeq;

    typedef sequence<unsigned short> TshortSeq;

    struct TPicture {
        unsigned short rowLength;
        TshortSeq      pixels;    //Concatenation of rows (starting in the lower left)
    };

    enum TData {DataNumber, DataString, DataPicture, DataNone};

    union TDataMixed switch(TData) {
        case DataNumber  : double   number;
        case DataString  : string   stringVal;
        case DataPicture : TPicture picture;
        case DataNone    : boolean outVal;
    };

    struct TMeasurement {
        unsigned short channel;   //== STI_Client_Server::TChannel.channel
        double         time;
        TDataMixed     data;
    };

    typedef sequence<TMeasurement>    TMeasurementSeq;    //List over measurements of one channel
    typedef sequence<TMeasurementSeq> TMeasurementSeqSeq; //List over channels of device


    // Device object.
    //Create two instances of this:
    // * Continuously running elements
    // * Timing critical measurements
    interface DataTransfer
    {
        readonly attribute string             errMsg;
        readonly attribute TMeasurementSeqSeq measurements;

        TMeasurementSeq getStreamingData(in unsigned short channel,
                                         in double         initial_t, 
                                         in double         final_t, 
                                         in double         delta_t);
    };

    enum TStatusLevel {LevelStopped, LevelRunning, LevelPaused, LevelError };

    struct TStatus {
        TStatusLevel   level;
        double         curTime;
        unsigned long  curEvent;
        unsigned short curCycle;
    };

    // DeviceServer object.
    interface DeviceControl
    {
        readonly attribute string errMsg;
        TStatus status();

        boolean transferEvents(in TDeviceEventSeq events, in boolean dryrun);

        void reset();
        void play();        //Prepare for playback on next trigger
		void pause();
        void trigger();     //Manually trigger playback
        void stop();        //Stop current playback
    };


    enum TChannelType {Output, Input, BiDirectional, Unknown};

    struct TDeviceChannel {
        unsigned short channel;
        TChannelType   type;
        // Types that this channel expects
        TData          inputType;
        TValue         outputType;
    };
    
    // Self-declared list of available channels for this device
    typedef sequence<TDeviceChannel>    TDeviceChannelSeq;

    struct TDevice {
        string          deviceName;
        string          address;
        unsigned short  moduleNum;
        string          deviceID;
        string          deviceContext;    // For registering with NameService
    };
    
    // Server object.  Devices establish contact with this (global) object and configure
    // the server for communication prior to making their servants live with orb->run()
    interface ServerConfigure
    {
        // The attributes required by the server for communication
        readonly attribute TAttributeSeq attributes;        
        readonly attribute string serverName;    //human-readable server id info

        // Returns true if registration is successful.
        // Asigns a unique TDevice.deviceID for the device.
        // The device uses the deviceID string to specify its attributes to the server.
        // The TDevice.deviceContext is used to register the device with the NameService.
        // This function (in particular, deviceID generation) MUST be thread safe!
        boolean registerDevice(inout TDevice device);

        // Let's a device set attributes for itself on the server
//        boolean setAttribute(in string deviceID, in string key, in string value);
//        string getAttribute(in string deviceID, in string key);

        // Let's a device tell the server what channels it has available
        boolean setChannels(in string deviceID, in TDeviceChannelSeq channels);

        // Tells the server to aquire the device's servants in the unique context .\<deviceID>\
        // The device's servants should be live and available on the NameService before making this call.
        // Since orb->run() must be called from the main thread, the acquisition of the server's
        // ServerConfigure object and the call to activateDevice() should be done from
        // a separate (low priority) thread.
        boolean activateDevice(in string deviceID);
        boolean removeDevice(in string deviceID);

		//used to generate deviceIDs for partner devices
		string generateDeviceID(in TDevice device);

    };

	interface CommandLine;

	interface CommandLine
	{
		readonly attribute TStringSeq requiredPartnerDevices;
		readonly attribute string deviceID;

		string execute(in string args);

		boolean registerPartnerDevice(in CommandLine partner);
		boolean unregisterPartnerDevice(in string deviceID);
	};

};

#endif

