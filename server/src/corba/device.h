// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __device_hh__
#define __device_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE STI_Server_Device

_CORBA_MODULE_BEG

  class TStringSeq_var;

  class TStringSeq : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef TStringSeq_var _var_type;
    inline TStringSeq() {}
    inline TStringSeq(const TStringSeq& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline TStringSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline TStringSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline TStringSeq& operator = (const TStringSeq& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class TStringSeq_out;

  class TStringSeq_var {
  public:
    inline TStringSeq_var() : _pd_seq(0) {}
    inline TStringSeq_var(TStringSeq* _s) : _pd_seq(_s) {}
    inline TStringSeq_var(const TStringSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TStringSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TStringSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TStringSeq_var& operator = (TStringSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TStringSeq_var& operator = (const TStringSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TStringSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TStringSeq* operator -> () { return _pd_seq; }
    inline const TStringSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TStringSeq& () const { return *_pd_seq; }
#else
    inline operator const TStringSeq& () const { return *_pd_seq; }
    inline operator TStringSeq& () { return *_pd_seq; }
#endif
      
    inline const TStringSeq& in() const { return *_pd_seq; }
    inline TStringSeq&       inout()    { return *_pd_seq; }
    inline TStringSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TStringSeq* _retn() { TStringSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TStringSeq_out;
    
  private:
    TStringSeq* _pd_seq;
  };

  class TStringSeq_out {
  public:
    inline TStringSeq_out(TStringSeq*& _s) : _data(_s) { _data = 0; }
    inline TStringSeq_out(TStringSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TStringSeq*) 0; }
    inline TStringSeq_out(const TStringSeq_out& _s) : _data(_s._data) {}
    inline TStringSeq_out& operator = (const TStringSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TStringSeq_out& operator = (TStringSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TStringSeq*&()  { return _data; }
    inline TStringSeq*& ptr()       { return _data; }
    inline TStringSeq* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TStringSeq*& _data;

  private:
    TStringSeq_out();
    TStringSeq_out& operator=(const TStringSeq_var&);
  };

  struct TAttribute {
    typedef _CORBA_ConstrType_Variable_Var<TAttribute> _var_type;

    
    ::CORBA::String_member key;

    ::CORBA::String_member value;

    TStringSeq values;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TAttribute::_var_type TAttribute_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TAttribute,TAttribute_var > TAttribute_out;

  class TAttributeSeq_var;

  class TAttributeSeq : public _CORBA_Unbounded_Sequence< TAttribute >  {
  public:
    typedef TAttributeSeq_var _var_type;
    inline TAttributeSeq() {}
    inline TAttributeSeq(const TAttributeSeq& _s)
      : _CORBA_Unbounded_Sequence< TAttribute > (_s) {}

    inline TAttributeSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TAttribute > (_max) {}
    inline TAttributeSeq(_CORBA_ULong _max, _CORBA_ULong _len, TAttribute* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TAttribute > (_max, _len, _val, _rel) {}

  

    inline TAttributeSeq& operator = (const TAttributeSeq& _s) {
      _CORBA_Unbounded_Sequence< TAttribute > ::operator=(_s);
      return *this;
    }
  };

  class TAttributeSeq_out;

  class TAttributeSeq_var {
  public:
    inline TAttributeSeq_var() : _pd_seq(0) {}
    inline TAttributeSeq_var(TAttributeSeq* _s) : _pd_seq(_s) {}
    inline TAttributeSeq_var(const TAttributeSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TAttributeSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TAttributeSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TAttributeSeq_var& operator = (TAttributeSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TAttributeSeq_var& operator = (const TAttributeSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TAttributeSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TAttribute& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TAttributeSeq* operator -> () { return _pd_seq; }
    inline const TAttributeSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TAttributeSeq& () const { return *_pd_seq; }
#else
    inline operator const TAttributeSeq& () const { return *_pd_seq; }
    inline operator TAttributeSeq& () { return *_pd_seq; }
#endif
      
    inline const TAttributeSeq& in() const { return *_pd_seq; }
    inline TAttributeSeq&       inout()    { return *_pd_seq; }
    inline TAttributeSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TAttributeSeq* _retn() { TAttributeSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TAttributeSeq_out;
    
  private:
    TAttributeSeq* _pd_seq;
  };

  class TAttributeSeq_out {
  public:
    inline TAttributeSeq_out(TAttributeSeq*& _s) : _data(_s) { _data = 0; }
    inline TAttributeSeq_out(TAttributeSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TAttributeSeq*) 0; }
    inline TAttributeSeq_out(const TAttributeSeq_out& _s) : _data(_s._data) {}
    inline TAttributeSeq_out& operator = (const TAttributeSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TAttributeSeq_out& operator = (TAttributeSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TAttributeSeq*&()  { return _data; }
    inline TAttributeSeq*& ptr()       { return _data; }
    inline TAttributeSeq* operator->() { return _data; }

    inline TAttribute& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TAttributeSeq*& _data;

  private:
    TAttributeSeq_out();
    TAttributeSeq_out& operator=(const TAttributeSeq_var&);
  };

#ifndef __STI__Server__Device_mConfigure__
#define __STI__Server__Device_mConfigure__

  class Configure;
  class _objref_Configure;
  class _impl_Configure;
  
  typedef _objref_Configure* Configure_ptr;
  typedef Configure_ptr ConfigureRef;

  class Configure_Helper {
  public:
    typedef Configure_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Configure, Configure_Helper> Configure_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Configure,Configure_Helper > Configure_out;

#endif

  // interface Configure
  class Configure {
  public:
    // Declarations for this interface type.
    typedef Configure_ptr _ptr_type;
    typedef Configure_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Configure :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Boolean setAttribute(const char* key, const char* value);
    char* getAttribute(const char* key);
    void reRegisterWithServer();
    void kill();
    TAttributeSeq* attributes();
    char* deviceName();

    inline _objref_Configure()  { _PR_setobj(0); }  // nil
    _objref_Configure(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Configure();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Configure(const _objref_Configure&);
    _objref_Configure& operator = (const _objref_Configure&);
    // not implemented

    friend class Configure;
  };

  class _pof_Configure : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Configure() : _OMNI_NS(proxyObjectFactory)(Configure::_PD_repoId) {}
    virtual ~_pof_Configure();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Configure :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Configure();

    virtual ::CORBA::Boolean setAttribute(const char* key, const char* value) = 0;
    virtual char* getAttribute(const char* key) = 0;
    virtual void reRegisterWithServer() = 0;
    virtual void kill() = 0;
    virtual TAttributeSeq* attributes() = 0;
    virtual char* deviceName() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  struct TDDS {
    typedef _CORBA_ConstrType_Fix_Var<TDDS> _var_type;

    
    ::CORBA::Double freq;

    ::CORBA::Double phase;

    ::CORBA::Double ampl;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDDS::_var_type TDDS_var;

  typedef TDDS& TDDS_out;

  enum TValue { ValueNumber, ValueString, ValueDDSTriplet, ValueMeas /*, __max_TValue=0xffffffff */ };
  typedef TValue& TValue_out;

  class TValMixed {
  public:

    typedef _CORBA_ConstrType_Variable_Var<TValMixed> _var_type;

    

    TValMixed(): _pd__initialised(0) {
      
    }
    
    TValMixed(const TValMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case ValueNumber: number(_value._pd_number); break;

        case ValueString: stringVal(_value._pd_stringVal); break;

        case ValueDDSTriplet: triplet(_value._pd_triplet); break;

        case ValueMeas: description(_value._pd_description); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
    }

    ~TValMixed() {}

    TValMixed& operator=(const TValMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case ValueNumber: number(_value._pd_number); break;

        case ValueString: stringVal(_value._pd_stringVal); break;

        case ValueDDSTriplet: triplet(_value._pd_triplet); break;

        case ValueMeas: description(_value._pd_description); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
      return *this;
    }

    TValue _d() const { return _pd__d;}
    void _d(TValue _value){
      // illegal to set discriminator before making a member active
      if (!_pd__initialised)
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

      if (_value == _pd__d) return; // no change

      switch (_pd__d){
        case ValueNumber: goto fail;
        case ValueString: goto fail;
        case ValueDDSTriplet: goto fail;
        case ValueMeas: goto fail;
        default: goto fail;

      };
      

      fail:
      OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


  
    }

    

    ::CORBA::Double number () const { return _pd_number; }
    void number (::CORBA::Double  _value) {
      _pd__initialised = 1;
      _pd__d = ValueNumber;
      _pd__default = 0;
      _pd_number = _value;
    }

    const char * stringVal () const { return (const char*) _pd_stringVal; }
    void stringVal(char* _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const char*  _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_var& _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_member& _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }

    const TDDS &triplet () const { return _pd_triplet; }
    TDDS &triplet () { return _pd_triplet; }
    void triplet (const TDDS& _value) {
      _pd__initialised = 1;
      _pd__d = ValueDDSTriplet;
      _pd__default = 0;
      _pd_triplet = _value;
    }

    const char * description () const { return (const char*) _pd_description; }
    void description(char* _value) {
      _pd__initialised = 1;
      _pd__d = ValueMeas;
      _pd__default = 0;
      _pd_description = _value;
    }
    void description(const char*  _value) {
      _pd__initialised = 1;
      _pd__d = ValueMeas;
      _pd__default = 0;
      _pd_description = _value;
    }
    void description(const ::CORBA::String_var& _value) {
      _pd__initialised = 1;
      _pd__d = ValueMeas;
      _pd__default = 0;
      _pd_description = _value;
    }
    void description(const ::CORBA::String_member& _value) {
      _pd__initialised = 1;
      _pd__d = ValueMeas;
      _pd__default = 0;
      _pd_description = _value;
    }

  
    
    void operator>>= (cdrStream&) const;
    void operator<<= (cdrStream&);

  private:
    TValue _pd__d;
    _CORBA_Boolean _pd__default;
    _CORBA_Boolean _pd__initialised;

    union {
      
#ifndef USING_PROXY_FLOAT
        ::CORBA::Double _pd_number;
#endif


    };

  
    
#ifdef USING_PROXY_FLOAT
      ::CORBA::Double _pd_number;
#endif

    ::CORBA::String_member _pd_stringVal;

    TDDS _pd_triplet;

    ::CORBA::String_member _pd_description;

  
  };

  typedef TValMixed::_var_type TValMixed_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TValMixed,TValMixed_var > TValMixed_out;

  struct TDeviceEvent {
    typedef _CORBA_ConstrType_Variable_Var<TDeviceEvent> _var_type;

    
    ::CORBA::UShort channel;

    ::CORBA::Double time;

    TValMixed value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDeviceEvent::_var_type TDeviceEvent_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TDeviceEvent,TDeviceEvent_var > TDeviceEvent_out;

  class TDeviceEventSeq_var;

  class TDeviceEventSeq : public _CORBA_Unbounded_Sequence< TDeviceEvent >  {
  public:
    typedef TDeviceEventSeq_var _var_type;
    inline TDeviceEventSeq() {}
    inline TDeviceEventSeq(const TDeviceEventSeq& _s)
      : _CORBA_Unbounded_Sequence< TDeviceEvent > (_s) {}

    inline TDeviceEventSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TDeviceEvent > (_max) {}
    inline TDeviceEventSeq(_CORBA_ULong _max, _CORBA_ULong _len, TDeviceEvent* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TDeviceEvent > (_max, _len, _val, _rel) {}

  

    inline TDeviceEventSeq& operator = (const TDeviceEventSeq& _s) {
      _CORBA_Unbounded_Sequence< TDeviceEvent > ::operator=(_s);
      return *this;
    }
  };

  class TDeviceEventSeq_out;

  class TDeviceEventSeq_var {
  public:
    inline TDeviceEventSeq_var() : _pd_seq(0) {}
    inline TDeviceEventSeq_var(TDeviceEventSeq* _s) : _pd_seq(_s) {}
    inline TDeviceEventSeq_var(const TDeviceEventSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TDeviceEventSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TDeviceEventSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TDeviceEventSeq_var& operator = (TDeviceEventSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TDeviceEventSeq_var& operator = (const TDeviceEventSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TDeviceEventSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TDeviceEvent& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TDeviceEventSeq* operator -> () { return _pd_seq; }
    inline const TDeviceEventSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TDeviceEventSeq& () const { return *_pd_seq; }
#else
    inline operator const TDeviceEventSeq& () const { return *_pd_seq; }
    inline operator TDeviceEventSeq& () { return *_pd_seq; }
#endif
      
    inline const TDeviceEventSeq& in() const { return *_pd_seq; }
    inline TDeviceEventSeq&       inout()    { return *_pd_seq; }
    inline TDeviceEventSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TDeviceEventSeq* _retn() { TDeviceEventSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TDeviceEventSeq_out;
    
  private:
    TDeviceEventSeq* _pd_seq;
  };

  class TDeviceEventSeq_out {
  public:
    inline TDeviceEventSeq_out(TDeviceEventSeq*& _s) : _data(_s) { _data = 0; }
    inline TDeviceEventSeq_out(TDeviceEventSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TDeviceEventSeq*) 0; }
    inline TDeviceEventSeq_out(const TDeviceEventSeq_out& _s) : _data(_s._data) {}
    inline TDeviceEventSeq_out& operator = (const TDeviceEventSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TDeviceEventSeq_out& operator = (TDeviceEventSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TDeviceEventSeq*&()  { return _data; }
    inline TDeviceEventSeq*& ptr()       { return _data; }
    inline TDeviceEventSeq* operator->() { return _data; }

    inline TDeviceEvent& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TDeviceEventSeq*& _data;

  private:
    TDeviceEventSeq_out();
    TDeviceEventSeq_out& operator=(const TDeviceEventSeq_var&);
  };

  class TshortSeq_var;

  class TshortSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 >  {
  public:
    typedef TshortSeq_var _var_type;
    inline TshortSeq() {}
    inline TshortSeq(const TshortSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_s) {}

    inline TshortSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max) {}
    inline TshortSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::UShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline TshortSeq& operator = (const TshortSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class TshortSeq_out;

  class TshortSeq_var {
  public:
    inline TshortSeq_var() : _pd_seq(0) {}
    inline TshortSeq_var(TshortSeq* _s) : _pd_seq(_s) {}
    inline TshortSeq_var(const TshortSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TshortSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TshortSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TshortSeq_var& operator = (TshortSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TshortSeq_var& operator = (const TshortSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TshortSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::UShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TshortSeq* operator -> () { return _pd_seq; }
    inline const TshortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TshortSeq& () const { return *_pd_seq; }
#else
    inline operator const TshortSeq& () const { return *_pd_seq; }
    inline operator TshortSeq& () { return *_pd_seq; }
#endif
      
    inline const TshortSeq& in() const { return *_pd_seq; }
    inline TshortSeq&       inout()    { return *_pd_seq; }
    inline TshortSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TshortSeq* _retn() { TshortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TshortSeq_out;
    
  private:
    TshortSeq* _pd_seq;
  };

  class TshortSeq_out {
  public:
    inline TshortSeq_out(TshortSeq*& _s) : _data(_s) { _data = 0; }
    inline TshortSeq_out(TshortSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TshortSeq*) 0; }
    inline TshortSeq_out(const TshortSeq_out& _s) : _data(_s._data) {}
    inline TshortSeq_out& operator = (const TshortSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TshortSeq_out& operator = (TshortSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TshortSeq*&()  { return _data; }
    inline TshortSeq*& ptr()       { return _data; }
    inline TshortSeq* operator->() { return _data; }

    inline ::CORBA::UShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TshortSeq*& _data;

  private:
    TshortSeq_out();
    TshortSeq_out& operator=(const TshortSeq_var&);
  };

  struct TPicture {
    typedef _CORBA_ConstrType_Variable_Var<TPicture> _var_type;

    
    ::CORBA::UShort rowLength;

    TshortSeq pixels;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TPicture::_var_type TPicture_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TPicture,TPicture_var > TPicture_out;

  enum TData { DataBoolean, DataOctet, DataLong, DataDouble, DataString, DataPicture, DataVector, DataNone /*, __max_TData=0xffffffff */ };
  typedef TData& TData_out;

  class TDataMixed;

  class TDataMixedSeq_var;

  class TDataMixedSeq : public _CORBA_Unbounded_Sequence_Forward< TDataMixed >  {
  public:
    typedef TDataMixedSeq_var _var_type;

    inline TDataMixedSeq() {}
    TDataMixedSeq(const TDataMixedSeq& _s);
    TDataMixedSeq& operator=(const TDataMixedSeq& _s);

    inline TDataMixedSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Forward< TDataMixed > (_max) {}
    inline TDataMixedSeq(_CORBA_ULong _max, _CORBA_ULong _len, TDataMixed* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Forward< TDataMixed > (_max, _len, _val, _rel) {}

  

    virtual ~TDataMixedSeq();

    TDataMixed& operator[] (_CORBA_ULong _index);
    const TDataMixed& operator[] (_CORBA_ULong _index) const;
    static TDataMixed* allocbuf(_CORBA_ULong _nelems);
    static void freebuf(TDataMixed* _b);

    void operator>>= (cdrStream &_s) const;
    void operator<<= (cdrStream &_s);

  protected:
    void NP_copybuffer(_CORBA_ULong _newmax);
    void NP_freebuf();
  };

  class TDataMixedSeq_out;

  class TDataMixedSeq_var {
  public:
    inline TDataMixedSeq_var() : _pd_seq(0) {}
    inline TDataMixedSeq_var(TDataMixedSeq* _s) : _pd_seq(_s) {}
    inline TDataMixedSeq_var(const TDataMixedSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TDataMixedSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TDataMixedSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TDataMixedSeq_var& operator = (TDataMixedSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TDataMixedSeq_var& operator = (const TDataMixedSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TDataMixedSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TDataMixed& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TDataMixedSeq* operator -> () { return _pd_seq; }
    inline const TDataMixedSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TDataMixedSeq& () const { return *_pd_seq; }
#else
    inline operator const TDataMixedSeq& () const { return *_pd_seq; }
    inline operator TDataMixedSeq& () { return *_pd_seq; }
#endif
      
    inline const TDataMixedSeq& in() const { return *_pd_seq; }
    inline TDataMixedSeq&       inout()    { return *_pd_seq; }
    inline TDataMixedSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TDataMixedSeq* _retn() { TDataMixedSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TDataMixedSeq_out;
    
  private:
    TDataMixedSeq* _pd_seq;
  };

  class TDataMixedSeq_out {
  public:
    inline TDataMixedSeq_out(TDataMixedSeq*& _s) : _data(_s) { _data = 0; }
    inline TDataMixedSeq_out(TDataMixedSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TDataMixedSeq*) 0; }
    inline TDataMixedSeq_out(const TDataMixedSeq_out& _s) : _data(_s._data) {}
    inline TDataMixedSeq_out& operator = (const TDataMixedSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TDataMixedSeq_out& operator = (TDataMixedSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TDataMixedSeq*&()  { return _data; }
    inline TDataMixedSeq*& ptr()       { return _data; }
    inline TDataMixedSeq* operator->() { return _data; }

    inline TDataMixed& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TDataMixedSeq*& _data;

  private:
    TDataMixedSeq_out();
    TDataMixedSeq_out& operator=(const TDataMixedSeq_var&);
  };

  class TDataMixed {
  public:

    typedef _CORBA_ConstrType_Variable_Var<TDataMixed> _var_type;

    

    TDataMixed(): _pd__initialised(0) {
      
    }
    
    TDataMixed(const TDataMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case DataBoolean: booleanVal(_value._pd_booleanVal); break;

        case DataOctet: octetVal(_value._pd_octetVal); break;

        case DataLong: longVal(_value._pd_longVal); break;

        case DataDouble: doubleVal(_value._pd_doubleVal); break;

        case DataString: stringVal(_value._pd_stringVal); break;

        case DataPicture: picture(_value._pd_picture); break;

        case DataVector: vector(_value._pd_vector); break;

        case DataNone: outVal(_value._pd_outVal); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
    }

    ~TDataMixed() {}

    TDataMixed& operator=(const TDataMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case DataBoolean: booleanVal(_value._pd_booleanVal); break;

        case DataOctet: octetVal(_value._pd_octetVal); break;

        case DataLong: longVal(_value._pd_longVal); break;

        case DataDouble: doubleVal(_value._pd_doubleVal); break;

        case DataString: stringVal(_value._pd_stringVal); break;

        case DataPicture: picture(_value._pd_picture); break;

        case DataVector: vector(_value._pd_vector); break;

        case DataNone: outVal(_value._pd_outVal); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
      return *this;
    }

    TData _d() const { return _pd__d;}
    void _d(TData _value){
      // illegal to set discriminator before making a member active
      if (!_pd__initialised)
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

      if (_value == _pd__d) return; // no change

      switch (_pd__d){
        case DataBoolean: goto fail;
        case DataOctet: goto fail;
        case DataLong: goto fail;
        case DataDouble: goto fail;
        case DataString: goto fail;
        case DataPicture: goto fail;
        case DataVector: goto fail;
        case DataNone: goto fail;
        default: goto fail;

      };
      

      fail:
      OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


  
    }

    

    ::CORBA::Boolean booleanVal () const { return _pd_booleanVal; }
    void booleanVal (::CORBA::Boolean  _value) {
      _pd__initialised = 1;
      _pd__d = DataBoolean;
      _pd__default = 0;
      _pd_booleanVal = _value;
    }

    ::CORBA::Octet octetVal () const { return _pd_octetVal; }
    void octetVal (::CORBA::Octet  _value) {
      _pd__initialised = 1;
      _pd__d = DataOctet;
      _pd__default = 0;
      _pd_octetVal = _value;
    }

    ::CORBA::Long longVal () const { return _pd_longVal; }
    void longVal (::CORBA::Long  _value) {
      _pd__initialised = 1;
      _pd__d = DataLong;
      _pd__default = 0;
      _pd_longVal = _value;
    }

    ::CORBA::Double doubleVal () const { return _pd_doubleVal; }
    void doubleVal (::CORBA::Double  _value) {
      _pd__initialised = 1;
      _pd__d = DataDouble;
      _pd__default = 0;
      _pd_doubleVal = _value;
    }

    const char * stringVal () const { return (const char*) _pd_stringVal; }
    void stringVal(char* _value) {
      _pd__initialised = 1;
      _pd__d = DataString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const char*  _value) {
      _pd__initialised = 1;
      _pd__d = DataString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_var& _value) {
      _pd__initialised = 1;
      _pd__d = DataString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_member& _value) {
      _pd__initialised = 1;
      _pd__d = DataString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }

    const TPicture &picture () const { return _pd_picture; }
    TPicture &picture () { return _pd_picture; }
    void picture (const TPicture& _value) {
      _pd__initialised = 1;
      _pd__d = DataPicture;
      _pd__default = 0;
      _pd_picture = _value;
    }

    const TDataMixedSeq &vector () const { return _pd_vector; }
    TDataMixedSeq &vector () { return _pd_vector; }
    void vector (const TDataMixedSeq& _value) {
      _pd__initialised = 1;
      _pd__d = DataVector;
      _pd__default = 0;
      _pd_vector = _value;
    }

    ::CORBA::Boolean outVal () const { return _pd_outVal; }
    void outVal (::CORBA::Boolean  _value) {
      _pd__initialised = 1;
      _pd__d = DataNone;
      _pd__default = 0;
      _pd_outVal = _value;
    }

  
    
    void operator>>= (cdrStream&) const;
    void operator<<= (cdrStream&);

  private:
    TData _pd__d;
    _CORBA_Boolean _pd__default;
    _CORBA_Boolean _pd__initialised;

    union {
      ::CORBA::Boolean _pd_booleanVal;

      ::CORBA::Octet _pd_octetVal;

      ::CORBA::Long _pd_longVal;


#ifndef USING_PROXY_FLOAT
        ::CORBA::Double _pd_doubleVal;
#endif

      ::CORBA::Boolean _pd_outVal;


    };

  
    
#ifdef USING_PROXY_FLOAT
      ::CORBA::Double _pd_doubleVal;
#endif

    ::CORBA::String_member _pd_stringVal;

    TPicture _pd_picture;

    TDataMixedSeq _pd_vector;

  
  };

  typedef TDataMixed::_var_type TDataMixed_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TDataMixed,TDataMixed_var > TDataMixed_out;

  struct TLabeledData {
    typedef _CORBA_ConstrType_Variable_Var<TLabeledData> _var_type;

    
    ::CORBA::String_member label;

    TDataMixed data;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TLabeledData::_var_type TLabeledData_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TLabeledData,TLabeledData_var > TLabeledData_out;

  struct TMeasurement {
    typedef _CORBA_ConstrType_Variable_Var<TMeasurement> _var_type;

    
    ::CORBA::UShort channel;

    ::CORBA::Double time;

    TDataMixed data;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TMeasurement::_var_type TMeasurement_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TMeasurement,TMeasurement_var > TMeasurement_out;

  class TMeasurementSeq_var;

  class TMeasurementSeq : public _CORBA_Unbounded_Sequence< TMeasurement >  {
  public:
    typedef TMeasurementSeq_var _var_type;
    inline TMeasurementSeq() {}
    inline TMeasurementSeq(const TMeasurementSeq& _s)
      : _CORBA_Unbounded_Sequence< TMeasurement > (_s) {}

    inline TMeasurementSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TMeasurement > (_max) {}
    inline TMeasurementSeq(_CORBA_ULong _max, _CORBA_ULong _len, TMeasurement* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TMeasurement > (_max, _len, _val, _rel) {}

  

    inline TMeasurementSeq& operator = (const TMeasurementSeq& _s) {
      _CORBA_Unbounded_Sequence< TMeasurement > ::operator=(_s);
      return *this;
    }
  };

  class TMeasurementSeq_out;

  class TMeasurementSeq_var {
  public:
    inline TMeasurementSeq_var() : _pd_seq(0) {}
    inline TMeasurementSeq_var(TMeasurementSeq* _s) : _pd_seq(_s) {}
    inline TMeasurementSeq_var(const TMeasurementSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TMeasurementSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TMeasurementSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TMeasurementSeq_var& operator = (TMeasurementSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TMeasurementSeq_var& operator = (const TMeasurementSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TMeasurementSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TMeasurement& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TMeasurementSeq* operator -> () { return _pd_seq; }
    inline const TMeasurementSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TMeasurementSeq& () const { return *_pd_seq; }
#else
    inline operator const TMeasurementSeq& () const { return *_pd_seq; }
    inline operator TMeasurementSeq& () { return *_pd_seq; }
#endif
      
    inline const TMeasurementSeq& in() const { return *_pd_seq; }
    inline TMeasurementSeq&       inout()    { return *_pd_seq; }
    inline TMeasurementSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TMeasurementSeq* _retn() { TMeasurementSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TMeasurementSeq_out;
    
  private:
    TMeasurementSeq* _pd_seq;
  };

  class TMeasurementSeq_out {
  public:
    inline TMeasurementSeq_out(TMeasurementSeq*& _s) : _data(_s) { _data = 0; }
    inline TMeasurementSeq_out(TMeasurementSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TMeasurementSeq*) 0; }
    inline TMeasurementSeq_out(const TMeasurementSeq_out& _s) : _data(_s._data) {}
    inline TMeasurementSeq_out& operator = (const TMeasurementSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TMeasurementSeq_out& operator = (TMeasurementSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TMeasurementSeq*&()  { return _data; }
    inline TMeasurementSeq*& ptr()       { return _data; }
    inline TMeasurementSeq* operator->() { return _data; }

    inline TMeasurement& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TMeasurementSeq*& _data;

  private:
    TMeasurementSeq_out();
    TMeasurementSeq_out& operator=(const TMeasurementSeq_var&);
  };

#ifndef __STI__Server__Device_mDataTransfer__
#define __STI__Server__Device_mDataTransfer__

  class DataTransfer;
  class _objref_DataTransfer;
  class _impl_DataTransfer;
  
  typedef _objref_DataTransfer* DataTransfer_ptr;
  typedef DataTransfer_ptr DataTransferRef;

  class DataTransfer_Helper {
  public:
    typedef DataTransfer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DataTransfer, DataTransfer_Helper> DataTransfer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DataTransfer,DataTransfer_Helper > DataTransfer_out;

#endif

  // interface DataTransfer
  class DataTransfer {
  public:
    // Declarations for this interface type.
    typedef DataTransfer_ptr _ptr_type;
    typedef DataTransfer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_DataTransfer :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    TMeasurementSeq* getStreamingData(::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t);
    TLabeledData* getData(const char* dataLabel);
    char* errMsg();
    TMeasurementSeq* measurements();

    inline _objref_DataTransfer()  { _PR_setobj(0); }  // nil
    _objref_DataTransfer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DataTransfer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DataTransfer(const _objref_DataTransfer&);
    _objref_DataTransfer& operator = (const _objref_DataTransfer&);
    // not implemented

    friend class DataTransfer;
  };

  class _pof_DataTransfer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DataTransfer() : _OMNI_NS(proxyObjectFactory)(DataTransfer::_PD_repoId) {}
    virtual ~_pof_DataTransfer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DataTransfer :
    public virtual omniServant
  {
  public:
    virtual ~_impl_DataTransfer();

    virtual TMeasurementSeq* getStreamingData(::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t) = 0;
    virtual TLabeledData* getData(const char* dataLabel) = 0;
    virtual char* errMsg() = 0;
    virtual TMeasurementSeq* measurements() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  enum TStatusLevel { LevelStopped, LevelRunning, LevelPaused, LevelError /*, __max_TStatusLevel=0xffffffff */ };
  typedef TStatusLevel& TStatusLevel_out;

  struct TStatus {
    typedef _CORBA_ConstrType_Fix_Var<TStatus> _var_type;

    
    TStatusLevel level;

    ::CORBA::Double curTime;

    ::CORBA::ULong curEvent;

    ::CORBA::UShort curCycle;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TStatus::_var_type TStatus_var;

  typedef TStatus& TStatus_out;

#ifndef __STI__Server__Device_mDeviceControl__
#define __STI__Server__Device_mDeviceControl__

  class DeviceControl;
  class _objref_DeviceControl;
  class _impl_DeviceControl;
  
  typedef _objref_DeviceControl* DeviceControl_ptr;
  typedef DeviceControl_ptr DeviceControlRef;

  class DeviceControl_Helper {
  public:
    typedef DeviceControl_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DeviceControl, DeviceControl_Helper> DeviceControl_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceControl,DeviceControl_Helper > DeviceControl_out;

#endif

  // interface DeviceControl
  class DeviceControl {
  public:
    // Declarations for this interface type.
    typedef DeviceControl_ptr _ptr_type;
    typedef DeviceControl_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_DeviceControl :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    TStatus status();
    ::CORBA::Boolean transferEvents(const TDeviceEventSeq& events, ::CORBA::Boolean dryrun);
    void reset();
    void load();
    void play();
    void pause();
    void stop();
    ::CORBA::Boolean ping();
    char* controlMsg();
    char* transferErr();
    ::CORBA::Boolean eventsParsed();
    ::CORBA::Boolean eventsLoaded();
    ::CORBA::Boolean eventsPlayed();

    inline _objref_DeviceControl()  { _PR_setobj(0); }  // nil
    _objref_DeviceControl(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DeviceControl();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DeviceControl(const _objref_DeviceControl&);
    _objref_DeviceControl& operator = (const _objref_DeviceControl&);
    // not implemented

    friend class DeviceControl;
  };

  class _pof_DeviceControl : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DeviceControl() : _OMNI_NS(proxyObjectFactory)(DeviceControl::_PD_repoId) {}
    virtual ~_pof_DeviceControl();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DeviceControl :
    public virtual omniServant
  {
  public:
    virtual ~_impl_DeviceControl();

    virtual TStatus status() = 0;
    virtual ::CORBA::Boolean transferEvents(const TDeviceEventSeq& events, ::CORBA::Boolean dryrun) = 0;
    virtual void reset() = 0;
    virtual void load() = 0;
    virtual void play() = 0;
    virtual void pause() = 0;
    virtual void stop() = 0;
    virtual ::CORBA::Boolean ping() = 0;
    virtual char* controlMsg() = 0;
    virtual char* transferErr() = 0;
    virtual ::CORBA::Boolean eventsParsed() = 0;
    virtual ::CORBA::Boolean eventsLoaded() = 0;
    virtual ::CORBA::Boolean eventsPlayed() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  enum TChannelType { Output, Input, BiDirectional, Unknown /*, __max_TChannelType=0xffffffff */ };
  typedef TChannelType& TChannelType_out;

  struct TDeviceChannel {
    typedef _CORBA_ConstrType_Fix_Var<TDeviceChannel> _var_type;

    
    ::CORBA::UShort channel;

    TChannelType type;

    TData inputType;

    TValue outputType;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDeviceChannel::_var_type TDeviceChannel_var;

  typedef TDeviceChannel& TDeviceChannel_out;

  class TDeviceChannelSeq_var;

  class TDeviceChannelSeq : public _CORBA_Unbounded_Sequence< TDeviceChannel >  {
  public:
    typedef TDeviceChannelSeq_var _var_type;
    inline TDeviceChannelSeq() {}
    inline TDeviceChannelSeq(const TDeviceChannelSeq& _s)
      : _CORBA_Unbounded_Sequence< TDeviceChannel > (_s) {}

    inline TDeviceChannelSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TDeviceChannel > (_max) {}
    inline TDeviceChannelSeq(_CORBA_ULong _max, _CORBA_ULong _len, TDeviceChannel* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TDeviceChannel > (_max, _len, _val, _rel) {}

  

    inline TDeviceChannelSeq& operator = (const TDeviceChannelSeq& _s) {
      _CORBA_Unbounded_Sequence< TDeviceChannel > ::operator=(_s);
      return *this;
    }
  };

  class TDeviceChannelSeq_out;

  class TDeviceChannelSeq_var {
  public:
    inline TDeviceChannelSeq_var() : _pd_seq(0) {}
    inline TDeviceChannelSeq_var(TDeviceChannelSeq* _s) : _pd_seq(_s) {}
    inline TDeviceChannelSeq_var(const TDeviceChannelSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TDeviceChannelSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TDeviceChannelSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TDeviceChannelSeq_var& operator = (TDeviceChannelSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TDeviceChannelSeq_var& operator = (const TDeviceChannelSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TDeviceChannelSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TDeviceChannel& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TDeviceChannelSeq* operator -> () { return _pd_seq; }
    inline const TDeviceChannelSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TDeviceChannelSeq& () const { return *_pd_seq; }
#else
    inline operator const TDeviceChannelSeq& () const { return *_pd_seq; }
    inline operator TDeviceChannelSeq& () { return *_pd_seq; }
#endif
      
    inline const TDeviceChannelSeq& in() const { return *_pd_seq; }
    inline TDeviceChannelSeq&       inout()    { return *_pd_seq; }
    inline TDeviceChannelSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TDeviceChannelSeq* _retn() { TDeviceChannelSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TDeviceChannelSeq_out;
    
  private:
    TDeviceChannelSeq* _pd_seq;
  };

  class TDeviceChannelSeq_out {
  public:
    inline TDeviceChannelSeq_out(TDeviceChannelSeq*& _s) : _data(_s) { _data = 0; }
    inline TDeviceChannelSeq_out(TDeviceChannelSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TDeviceChannelSeq*) 0; }
    inline TDeviceChannelSeq_out(const TDeviceChannelSeq_out& _s) : _data(_s._data) {}
    inline TDeviceChannelSeq_out& operator = (const TDeviceChannelSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TDeviceChannelSeq_out& operator = (TDeviceChannelSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TDeviceChannelSeq*&()  { return _data; }
    inline TDeviceChannelSeq*& ptr()       { return _data; }
    inline TDeviceChannelSeq* operator->() { return _data; }

    inline TDeviceChannel& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TDeviceChannelSeq*& _data;

  private:
    TDeviceChannelSeq_out();
    TDeviceChannelSeq_out& operator=(const TDeviceChannelSeq_var&);
  };

  struct TDevice {
    typedef _CORBA_ConstrType_Variable_Var<TDevice> _var_type;

    
    ::CORBA::String_member deviceName;

    ::CORBA::String_member address;

    ::CORBA::UShort moduleNum;

    ::CORBA::String_member deviceID;

    ::CORBA::String_member deviceContext;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDevice::_var_type TDevice_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TDevice,TDevice_var > TDevice_out;

  enum TMessageType { LoadingError, PlayingError, DeviceError /*, __max_TMessageType=0xffffffff */ };
  typedef TMessageType& TMessageType_out;

#ifndef __STI__Server__Device_mServerConfigure__
#define __STI__Server__Device_mServerConfigure__

  class ServerConfigure;
  class _objref_ServerConfigure;
  class _impl_ServerConfigure;
  
  typedef _objref_ServerConfigure* ServerConfigure_ptr;
  typedef ServerConfigure_ptr ServerConfigureRef;

  class ServerConfigure_Helper {
  public:
    typedef ServerConfigure_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ServerConfigure, ServerConfigure_Helper> ServerConfigure_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ServerConfigure,ServerConfigure_Helper > ServerConfigure_out;

#endif

  // interface ServerConfigure
  class ServerConfigure {
  public:
    // Declarations for this interface type.
    typedef ServerConfigure_ptr _ptr_type;
    typedef ServerConfigure_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ServerConfigure :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Boolean registerDevice(TDevice& device);
    ::CORBA::Boolean setChannels(const char* deviceID, const TDeviceChannelSeq& channels);
    ::CORBA::Boolean activateDevice(const char* deviceID);
    ::CORBA::Boolean removeDevice(const char* deviceID);
    char* generateDeviceID(const TDevice& device);
    void reportMessage(const char* deviceID, TMessageType type, const char* message);
    TAttributeSeq* attributes();
    char* serverName();

    inline _objref_ServerConfigure()  { _PR_setobj(0); }  // nil
    _objref_ServerConfigure(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ServerConfigure();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ServerConfigure(const _objref_ServerConfigure&);
    _objref_ServerConfigure& operator = (const _objref_ServerConfigure&);
    // not implemented

    friend class ServerConfigure;
  };

  class _pof_ServerConfigure : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ServerConfigure() : _OMNI_NS(proxyObjectFactory)(ServerConfigure::_PD_repoId) {}
    virtual ~_pof_ServerConfigure();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ServerConfigure :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ServerConfigure();

    virtual ::CORBA::Boolean registerDevice(TDevice& device) = 0;
    virtual ::CORBA::Boolean setChannels(const char* deviceID, const TDeviceChannelSeq& channels) = 0;
    virtual ::CORBA::Boolean activateDevice(const char* deviceID) = 0;
    virtual ::CORBA::Boolean removeDevice(const char* deviceID) = 0;
    virtual char* generateDeviceID(const TDevice& device) = 0;
    virtual void reportMessage(const char* deviceID, TMessageType type, const char* message) = 0;
    virtual TAttributeSeq* attributes() = 0;
    virtual char* serverName() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __STI__Server__Device_mCommandLine__
#define __STI__Server__Device_mCommandLine__

  class CommandLine;
  class _objref_CommandLine;
  class _impl_CommandLine;
  
  typedef _objref_CommandLine* CommandLine_ptr;
  typedef CommandLine_ptr CommandLineRef;

  class CommandLine_Helper {
  public:
    typedef CommandLine_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_CommandLine, CommandLine_Helper> CommandLine_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_CommandLine,CommandLine_Helper > CommandLine_out;

#endif

#ifndef __STI__Server__Device_mCommandLine__
#define __STI__Server__Device_mCommandLine__

  class CommandLine;
  class _objref_CommandLine;
  class _impl_CommandLine;
  
  typedef _objref_CommandLine* CommandLine_ptr;
  typedef CommandLine_ptr CommandLineRef;

  class CommandLine_Helper {
  public:
    typedef CommandLine_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_CommandLine, CommandLine_Helper> CommandLine_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_CommandLine,CommandLine_Helper > CommandLine_out;

#endif

  // interface CommandLine
  class CommandLine {
  public:
    // Declarations for this interface type.
    typedef CommandLine_ptr _ptr_type;
    typedef CommandLine_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_CommandLine :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    char* execute(const char* args);
    ::CORBA::Boolean setAttribute(const char* key, const char* value);
    char* getAttribute(const char* key);
    ::CORBA::Boolean registerPartnerDevice(CommandLine_ptr partner);
    ::CORBA::Boolean unregisterPartnerDevice(const char* deviceID);
    ::CORBA::Boolean transferPartnerEvents(const TDeviceEventSeq& events);
    TStringSeq* requiredPartnerDevices();
    TStringSeq* registeredPartnerDevices();
    TDevice* device();

    inline _objref_CommandLine()  { _PR_setobj(0); }  // nil
    _objref_CommandLine(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_CommandLine();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_CommandLine(const _objref_CommandLine&);
    _objref_CommandLine& operator = (const _objref_CommandLine&);
    // not implemented

    friend class CommandLine;
  };

  class _pof_CommandLine : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_CommandLine() : _OMNI_NS(proxyObjectFactory)(CommandLine::_PD_repoId) {}
    virtual ~_pof_CommandLine();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_CommandLine :
    public virtual omniServant
  {
  public:
    virtual ~_impl_CommandLine();

    virtual char* execute(const char* args) = 0;
    virtual ::CORBA::Boolean setAttribute(const char* key, const char* value) = 0;
    virtual char* getAttribute(const char* key) = 0;
    virtual ::CORBA::Boolean registerPartnerDevice(CommandLine_ptr partner) = 0;
    virtual ::CORBA::Boolean unregisterPartnerDevice(const char* deviceID) = 0;
    virtual ::CORBA::Boolean transferPartnerEvents(const TDeviceEventSeq& events) = 0;
    virtual TStringSeq* requiredPartnerDevices() = 0;
    virtual TStringSeq* registeredPartnerDevices() = 0;
    virtual TDevice* device() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_STI_Server_Device
_CORBA_MODULE_BEG

  class Configure :
    public virtual STI_Server_Device::_impl_Configure,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Configure();

    inline ::STI_Server_Device::Configure_ptr _this() {
      return (::STI_Server_Device::Configure_ptr) _do_this(::STI_Server_Device::Configure::_PD_repoId);
    }
  };

  class DataTransfer :
    public virtual STI_Server_Device::_impl_DataTransfer,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~DataTransfer();

    inline ::STI_Server_Device::DataTransfer_ptr _this() {
      return (::STI_Server_Device::DataTransfer_ptr) _do_this(::STI_Server_Device::DataTransfer::_PD_repoId);
    }
  };

  class DeviceControl :
    public virtual STI_Server_Device::_impl_DeviceControl,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~DeviceControl();

    inline ::STI_Server_Device::DeviceControl_ptr _this() {
      return (::STI_Server_Device::DeviceControl_ptr) _do_this(::STI_Server_Device::DeviceControl::_PD_repoId);
    }
  };

  class ServerConfigure :
    public virtual STI_Server_Device::_impl_ServerConfigure,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ServerConfigure();

    inline ::STI_Server_Device::ServerConfigure_ptr _this() {
      return (::STI_Server_Device::ServerConfigure_ptr) _do_this(::STI_Server_Device::ServerConfigure::_PD_repoId);
    }
  };

  class CommandLine :
    public virtual STI_Server_Device::_impl_CommandLine,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~CommandLine();

    inline ::STI_Server_Device::CommandLine_ptr _this() {
      return (::STI_Server_Device::CommandLine_ptr) _do_this(::STI_Server_Device::CommandLine::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_STI_Server_Device
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(STI_Server_Device::TValue _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Server_Device::TValue& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Server_Device::ValueMeas) {
    _e = (STI_Server_Device::TValue) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI_Server_Device::TData _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Server_Device::TData& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Server_Device::DataNone) {
    _e = (STI_Server_Device::TData) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI_Server_Device::TStatusLevel _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Server_Device::TStatusLevel& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Server_Device::LevelError) {
    _e = (STI_Server_Device::TStatusLevel) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI_Server_Device::TChannelType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Server_Device::TChannelType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Server_Device::Unknown) {
    _e = (STI_Server_Device::TChannelType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI_Server_Device::TMessageType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Server_Device::TMessageType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Server_Device::DeviceError) {
    _e = (STI_Server_Device::TMessageType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}



inline void
STI_Server_Device::Configure::_marshalObjRef(::STI_Server_Device::Configure_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Server_Device::DataTransfer::_marshalObjRef(::STI_Server_Device::DataTransfer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Server_Device::DeviceControl::_marshalObjRef(::STI_Server_Device::DeviceControl_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Server_Device::ServerConfigure::_marshalObjRef(::STI_Server_Device::ServerConfigure_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Server_Device::CommandLine::_marshalObjRef(::STI_Server_Device::CommandLine_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
#endif

#endif  // __device_hh__

