// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __client_hh__
#define __client_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_client
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE STI_Client_Server

_CORBA_MODULE_BEG

  struct TOverwritten {
    typedef _CORBA_ConstrType_Variable_Var<TOverwritten> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::String_member value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TOverwritten::_var_type TOverwritten_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TOverwritten,TOverwritten_var > TOverwritten_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TOverwritten;

  struct TDevice {
    typedef _CORBA_ConstrType_Variable_Var<TDevice> _var_type;

    
    ::CORBA::String_member deviceType;

    ::CORBA::String_member address;

    ::CORBA::UShort moduleType;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDevice::_var_type TDevice_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TDevice,TDevice_var > TDevice_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TDevice;

  struct TChannel {
    typedef _CORBA_ConstrType_Variable_Var<TChannel> _var_type;

    
    TDevice device;

    ::CORBA::UShort channel;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TChannel::_var_type TChannel_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TChannel,TChannel_var > TChannel_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TChannel;

  enum TType { TypeNumber, TypeString, TypeChannel, TypeObject /*, __max_TType=0xffffffff */ };
  typedef TType& TType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TType;

  class TVarMixed {
  public:

    typedef _CORBA_ConstrType_Variable_Var<TVarMixed> _var_type;

    

    TVarMixed(): _pd__initialised(0) {
      
    }
    
    TVarMixed(const TVarMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case TypeNumber: number(_value._pd_number); break;

        case TypeString: stringVal(_value._pd_stringVal); break;

        case TypeChannel: channel(_value._pd_channel); break;

        case TypeObject: objectVal(_value._pd_objectVal); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
    }

    ~TVarMixed() {}

    TVarMixed& operator=(const TVarMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case TypeNumber: number(_value._pd_number); break;

        case TypeString: stringVal(_value._pd_stringVal); break;

        case TypeChannel: channel(_value._pd_channel); break;

        case TypeObject: objectVal(_value._pd_objectVal); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
      return *this;
    }

    TType _d() const { return _pd__d;}
    void _d(TType _value){
      // illegal to set discriminator before making a member active
      if (!_pd__initialised)
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

      if (_value == _pd__d) return; // no change

      switch (_pd__d){
        case TypeNumber: goto fail;
        case TypeString: goto fail;
        case TypeChannel: goto fail;
        case TypeObject: goto fail;
        default: goto fail;

      };
      

      fail:
      OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


  
    }

    

    ::CORBA::Double number () const { return _pd_number; }
    void number (::CORBA::Double  _value) {
      _pd__initialised = 1;
      _pd__d = TypeNumber;
      _pd__default = 0;
      _pd_number = _value;
    }

    const char * stringVal () const { return (const char*) _pd_stringVal; }
    void stringVal(char* _value) {
      _pd__initialised = 1;
      _pd__d = TypeString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const char*  _value) {
      _pd__initialised = 1;
      _pd__d = TypeString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_var& _value) {
      _pd__initialised = 1;
      _pd__d = TypeString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_member& _value) {
      _pd__initialised = 1;
      _pd__d = TypeString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }

    ::CORBA::UShort channel () const { return _pd_channel; }
    void channel (::CORBA::UShort  _value) {
      _pd__initialised = 1;
      _pd__d = TypeChannel;
      _pd__default = 0;
      _pd_channel = _value;
    }

    const char * objectVal () const { return (const char*) _pd_objectVal; }
    void objectVal(char* _value) {
      _pd__initialised = 1;
      _pd__d = TypeObject;
      _pd__default = 0;
      _pd_objectVal = _value;
    }
    void objectVal(const char*  _value) {
      _pd__initialised = 1;
      _pd__d = TypeObject;
      _pd__default = 0;
      _pd_objectVal = _value;
    }
    void objectVal(const ::CORBA::String_var& _value) {
      _pd__initialised = 1;
      _pd__d = TypeObject;
      _pd__default = 0;
      _pd_objectVal = _value;
    }
    void objectVal(const ::CORBA::String_member& _value) {
      _pd__initialised = 1;
      _pd__d = TypeObject;
      _pd__default = 0;
      _pd_objectVal = _value;
    }

  
    
    void operator>>= (cdrStream&) const;
    void operator<<= (cdrStream&);

  private:
    TType _pd__d;
    _CORBA_Boolean _pd__default;
    _CORBA_Boolean _pd__initialised;

    union {
      
#ifndef USING_PROXY_FLOAT
        ::CORBA::Double _pd_number;
#endif

      ::CORBA::UShort _pd_channel;


    };

  
    
#ifdef USING_PROXY_FLOAT
      ::CORBA::Double _pd_number;
#endif

    ::CORBA::String_member _pd_stringVal;

    ::CORBA::String_member _pd_objectVal;

  
  };

  typedef TVarMixed::_var_type TVarMixed_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TVarMixed,TVarMixed_var > TVarMixed_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TVarMixed;

  struct TPosition {
    typedef _CORBA_ConstrType_Fix_Var<TPosition> _var_type;

    
    ::CORBA::UShort file;

    ::CORBA::ULong line;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TPosition::_var_type TPosition_var;

  typedef TPosition& TPosition_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TPosition;

  struct TVariable {
    typedef _CORBA_ConstrType_Variable_Var<TVariable> _var_type;

    
    ::CORBA::String_member name;

    TVarMixed value;

    TPosition pos;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TVariable::_var_type TVariable_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TVariable,TVariable_var > TVariable_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TVariable;

  struct TDDS {
    typedef _CORBA_ConstrType_Fix_Var<TDDS> _var_type;

    
    ::CORBA::Double freq;

    ::CORBA::Double phase;

    ::CORBA::Double ampl;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDDS::_var_type TDDS_var;

  typedef TDDS& TDDS_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TDDS;

  enum TValue { ValueNumber, ValueString, ValueDDSTriplet /*, __max_TValue=0xffffffff */ };
  typedef TValue& TValue_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TValue;

  class TValMixed {
  public:

    typedef _CORBA_ConstrType_Variable_Var<TValMixed> _var_type;

    

    TValMixed(): _pd__initialised(0) {
      
    }
    
    TValMixed(const TValMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case ValueNumber: number(_value._pd_number); break;

        case ValueString: stringVal(_value._pd_stringVal); break;

        case ValueDDSTriplet: triplet(_value._pd_triplet); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
    }

    ~TValMixed() {}

    TValMixed& operator=(const TValMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case ValueNumber: number(_value._pd_number); break;

        case ValueString: stringVal(_value._pd_stringVal); break;

        case ValueDDSTriplet: triplet(_value._pd_triplet); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
      return *this;
    }

    TValue _d() const { return _pd__d;}
    void _d(TValue _value){
      // illegal to set discriminator before making a member active
      if (!_pd__initialised)
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

      if (_value == _pd__d) return; // no change

      switch (_pd__d){
        case ValueNumber: goto fail;
        case ValueString: goto fail;
        case ValueDDSTriplet: goto fail;
        default: goto fail;

      };
      

      fail:
      OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


  
    }

    

    ::CORBA::Double number () const { return _pd_number; }
    void number (::CORBA::Double  _value) {
      _pd__initialised = 1;
      _pd__d = ValueNumber;
      _pd__default = 0;
      _pd_number = _value;
    }

    const char * stringVal () const { return (const char*) _pd_stringVal; }
    void stringVal(char* _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const char*  _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_var& _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_member& _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }

    const TDDS &triplet () const { return _pd_triplet; }
    TDDS &triplet () { return _pd_triplet; }
    void triplet (const TDDS& _value) {
      _pd__initialised = 1;
      _pd__d = ValueDDSTriplet;
      _pd__default = 0;
      _pd_triplet = _value;
    }

  
    
    void operator>>= (cdrStream&) const;
    void operator<<= (cdrStream&);

  private:
    TValue _pd__d;
    _CORBA_Boolean _pd__default;
    _CORBA_Boolean _pd__initialised;

    union {
      
#ifndef USING_PROXY_FLOAT
        ::CORBA::Double _pd_number;
#endif


    };

  
    
#ifdef USING_PROXY_FLOAT
      ::CORBA::Double _pd_number;
#endif

    ::CORBA::String_member _pd_stringVal;

    TDDS _pd_triplet;

  
  };

  typedef TValMixed::_var_type TValMixed_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TValMixed,TValMixed_var > TValMixed_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TValMixed;

  struct TEvent {
    typedef _CORBA_ConstrType_Variable_Var<TEvent> _var_type;

    
    ::CORBA::UShort channel;

    ::CORBA::Double time;

    TValMixed value;

    TPosition pos;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TEvent::_var_type TEvent_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TEvent,TEvent_var > TEvent_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TEvent;

#ifndef __STI__Client__Server_mModeHandler__
#define __STI__Client__Server_mModeHandler__

  class ModeHandler;
  class _objref_ModeHandler;
  class _impl_ModeHandler;
  
  typedef _objref_ModeHandler* ModeHandler_ptr;
  typedef ModeHandler_ptr ModeHandlerRef;

  class ModeHandler_Helper {
  public:
    typedef ModeHandler_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ModeHandler, ModeHandler_Helper> ModeHandler_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ModeHandler,ModeHandler_Helper > ModeHandler_out;

#endif

  // interface ModeHandler
  class ModeHandler {
  public:
    // Declarations for this interface type.
    typedef ModeHandler_ptr _ptr_type;
    typedef ModeHandler_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ModeHandler :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Boolean requestControl(const char* myName);
    void answerRequest(::CORBA::Boolean yield);
    char* controller();
    void controller(const char* _v);
    ::CORBA::Boolean requestPending();
    void requestPending(::CORBA::Boolean _v);
    char* requesterName();
    void requesterName(const char* _v);

    inline _objref_ModeHandler()  { _PR_setobj(0); }  // nil
    _objref_ModeHandler(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ModeHandler();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ModeHandler(const _objref_ModeHandler&);
    _objref_ModeHandler& operator = (const _objref_ModeHandler&);
    // not implemented

    friend class ModeHandler;
  };

  class _pof_ModeHandler : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ModeHandler() : _OMNI_NS(proxyObjectFactory)(ModeHandler::_PD_repoId) {}
    virtual ~_pof_ModeHandler();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ModeHandler :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ModeHandler();

    virtual ::CORBA::Boolean requestControl(const char* myName) = 0;
    virtual void answerRequest(::CORBA::Boolean yield) = 0;
    virtual char* controller() = 0;
    virtual void controller(const char* _v) = 0;
    virtual ::CORBA::Boolean requestPending() = 0;
    virtual void requestPending(::CORBA::Boolean _v) = 0;
    virtual char* requesterName() = 0;
    virtual void requesterName(const char* _v) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ModeHandler;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TOverwrittenSeq;

  class TOverwrittenSeq_var;

  class TOverwrittenSeq : public _CORBA_Unbounded_Sequence< TOverwritten >  {
  public:
    typedef TOverwrittenSeq_var _var_type;
    inline TOverwrittenSeq() {}
    inline TOverwrittenSeq(const TOverwrittenSeq& _s)
      : _CORBA_Unbounded_Sequence< TOverwritten > (_s) {}

    inline TOverwrittenSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TOverwritten > (_max) {}
    inline TOverwrittenSeq(_CORBA_ULong _max, _CORBA_ULong _len, TOverwritten* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TOverwritten > (_max, _len, _val, _rel) {}

  

    inline TOverwrittenSeq& operator = (const TOverwrittenSeq& _s) {
      _CORBA_Unbounded_Sequence< TOverwritten > ::operator=(_s);
      return *this;
    }
  };

  class TOverwrittenSeq_out;

  class TOverwrittenSeq_var {
  public:
    inline TOverwrittenSeq_var() : _pd_seq(0) {}
    inline TOverwrittenSeq_var(TOverwrittenSeq* _s) : _pd_seq(_s) {}
    inline TOverwrittenSeq_var(const TOverwrittenSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TOverwrittenSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TOverwrittenSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TOverwrittenSeq_var& operator = (TOverwrittenSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TOverwrittenSeq_var& operator = (const TOverwrittenSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TOverwrittenSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TOverwritten& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TOverwrittenSeq* operator -> () { return _pd_seq; }
    inline const TOverwrittenSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TOverwrittenSeq& () const { return *_pd_seq; }
#else
    inline operator const TOverwrittenSeq& () const { return *_pd_seq; }
    inline operator TOverwrittenSeq& () { return *_pd_seq; }
#endif
      
    inline const TOverwrittenSeq& in() const { return *_pd_seq; }
    inline TOverwrittenSeq&       inout()    { return *_pd_seq; }
    inline TOverwrittenSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TOverwrittenSeq* _retn() { TOverwrittenSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TOverwrittenSeq_out;
    
  private:
    TOverwrittenSeq* _pd_seq;
  };

  class TOverwrittenSeq_out {
  public:
    inline TOverwrittenSeq_out(TOverwrittenSeq*& _s) : _data(_s) { _data = 0; }
    inline TOverwrittenSeq_out(TOverwrittenSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TOverwrittenSeq*) 0; }
    inline TOverwrittenSeq_out(const TOverwrittenSeq_out& _s) : _data(_s._data) {}
    inline TOverwrittenSeq_out& operator = (const TOverwrittenSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TOverwrittenSeq_out& operator = (TOverwrittenSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TOverwrittenSeq*&()  { return _data; }
    inline TOverwrittenSeq*& ptr()       { return _data; }
    inline TOverwrittenSeq* operator->() { return _data; }

    inline TOverwritten& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TOverwrittenSeq*& _data;

  private:
    TOverwrittenSeq_out();
    TOverwrittenSeq_out& operator=(const TOverwrittenSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TChannelSeq;

  class TChannelSeq_var;

  class TChannelSeq : public _CORBA_Unbounded_Sequence< TChannel >  {
  public:
    typedef TChannelSeq_var _var_type;
    inline TChannelSeq() {}
    inline TChannelSeq(const TChannelSeq& _s)
      : _CORBA_Unbounded_Sequence< TChannel > (_s) {}

    inline TChannelSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TChannel > (_max) {}
    inline TChannelSeq(_CORBA_ULong _max, _CORBA_ULong _len, TChannel* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TChannel > (_max, _len, _val, _rel) {}

  

    inline TChannelSeq& operator = (const TChannelSeq& _s) {
      _CORBA_Unbounded_Sequence< TChannel > ::operator=(_s);
      return *this;
    }
  };

  class TChannelSeq_out;

  class TChannelSeq_var {
  public:
    inline TChannelSeq_var() : _pd_seq(0) {}
    inline TChannelSeq_var(TChannelSeq* _s) : _pd_seq(_s) {}
    inline TChannelSeq_var(const TChannelSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TChannelSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TChannelSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TChannelSeq_var& operator = (TChannelSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TChannelSeq_var& operator = (const TChannelSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TChannelSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TChannel& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TChannelSeq* operator -> () { return _pd_seq; }
    inline const TChannelSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TChannelSeq& () const { return *_pd_seq; }
#else
    inline operator const TChannelSeq& () const { return *_pd_seq; }
    inline operator TChannelSeq& () { return *_pd_seq; }
#endif
      
    inline const TChannelSeq& in() const { return *_pd_seq; }
    inline TChannelSeq&       inout()    { return *_pd_seq; }
    inline TChannelSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TChannelSeq* _retn() { TChannelSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TChannelSeq_out;
    
  private:
    TChannelSeq* _pd_seq;
  };

  class TChannelSeq_out {
  public:
    inline TChannelSeq_out(TChannelSeq*& _s) : _data(_s) { _data = 0; }
    inline TChannelSeq_out(TChannelSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TChannelSeq*) 0; }
    inline TChannelSeq_out(const TChannelSeq_out& _s) : _data(_s._data) {}
    inline TChannelSeq_out& operator = (const TChannelSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TChannelSeq_out& operator = (TChannelSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TChannelSeq*&()  { return _data; }
    inline TChannelSeq*& ptr()       { return _data; }
    inline TChannelSeq* operator->() { return _data; }

    inline TChannel& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TChannelSeq*& _data;

  private:
    TChannelSeq_out();
    TChannelSeq_out& operator=(const TChannelSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TStringSeq;

  class TStringSeq_var;

  class TStringSeq : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef TStringSeq_var _var_type;
    inline TStringSeq() {}
    inline TStringSeq(const TStringSeq& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline TStringSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline TStringSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline TStringSeq& operator = (const TStringSeq& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class TStringSeq_out;

  class TStringSeq_var {
  public:
    inline TStringSeq_var() : _pd_seq(0) {}
    inline TStringSeq_var(TStringSeq* _s) : _pd_seq(_s) {}
    inline TStringSeq_var(const TStringSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TStringSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TStringSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TStringSeq_var& operator = (TStringSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TStringSeq_var& operator = (const TStringSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TStringSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TStringSeq* operator -> () { return _pd_seq; }
    inline const TStringSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TStringSeq& () const { return *_pd_seq; }
#else
    inline operator const TStringSeq& () const { return *_pd_seq; }
    inline operator TStringSeq& () { return *_pd_seq; }
#endif
      
    inline const TStringSeq& in() const { return *_pd_seq; }
    inline TStringSeq&       inout()    { return *_pd_seq; }
    inline TStringSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TStringSeq* _retn() { TStringSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TStringSeq_out;
    
  private:
    TStringSeq* _pd_seq;
  };

  class TStringSeq_out {
  public:
    inline TStringSeq_out(TStringSeq*& _s) : _data(_s) { _data = 0; }
    inline TStringSeq_out(TStringSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TStringSeq*) 0; }
    inline TStringSeq_out(const TStringSeq_out& _s) : _data(_s._data) {}
    inline TStringSeq_out& operator = (const TStringSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TStringSeq_out& operator = (TStringSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TStringSeq*&()  { return _data; }
    inline TStringSeq*& ptr()       { return _data; }
    inline TStringSeq* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TStringSeq*& _data;

  private:
    TStringSeq_out();
    TStringSeq_out& operator=(const TStringSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TVariableSeq;

  class TVariableSeq_var;

  class TVariableSeq : public _CORBA_Unbounded_Sequence< TVariable >  {
  public:
    typedef TVariableSeq_var _var_type;
    inline TVariableSeq() {}
    inline TVariableSeq(const TVariableSeq& _s)
      : _CORBA_Unbounded_Sequence< TVariable > (_s) {}

    inline TVariableSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TVariable > (_max) {}
    inline TVariableSeq(_CORBA_ULong _max, _CORBA_ULong _len, TVariable* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TVariable > (_max, _len, _val, _rel) {}

  

    inline TVariableSeq& operator = (const TVariableSeq& _s) {
      _CORBA_Unbounded_Sequence< TVariable > ::operator=(_s);
      return *this;
    }
  };

  class TVariableSeq_out;

  class TVariableSeq_var {
  public:
    inline TVariableSeq_var() : _pd_seq(0) {}
    inline TVariableSeq_var(TVariableSeq* _s) : _pd_seq(_s) {}
    inline TVariableSeq_var(const TVariableSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TVariableSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TVariableSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TVariableSeq_var& operator = (TVariableSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TVariableSeq_var& operator = (const TVariableSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TVariableSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TVariable& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TVariableSeq* operator -> () { return _pd_seq; }
    inline const TVariableSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TVariableSeq& () const { return *_pd_seq; }
#else
    inline operator const TVariableSeq& () const { return *_pd_seq; }
    inline operator TVariableSeq& () { return *_pd_seq; }
#endif
      
    inline const TVariableSeq& in() const { return *_pd_seq; }
    inline TVariableSeq&       inout()    { return *_pd_seq; }
    inline TVariableSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TVariableSeq* _retn() { TVariableSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TVariableSeq_out;
    
  private:
    TVariableSeq* _pd_seq;
  };

  class TVariableSeq_out {
  public:
    inline TVariableSeq_out(TVariableSeq*& _s) : _data(_s) { _data = 0; }
    inline TVariableSeq_out(TVariableSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TVariableSeq*) 0; }
    inline TVariableSeq_out(const TVariableSeq_out& _s) : _data(_s._data) {}
    inline TVariableSeq_out& operator = (const TVariableSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TVariableSeq_out& operator = (TVariableSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TVariableSeq*&()  { return _data; }
    inline TVariableSeq*& ptr()       { return _data; }
    inline TVariableSeq* operator->() { return _data; }

    inline TVariable& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TVariableSeq*& _data;

  private:
    TVariableSeq_out();
    TVariableSeq_out& operator=(const TVariableSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TEventSeq;

  class TEventSeq_var;

  class TEventSeq : public _CORBA_Unbounded_Sequence< TEvent >  {
  public:
    typedef TEventSeq_var _var_type;
    inline TEventSeq() {}
    inline TEventSeq(const TEventSeq& _s)
      : _CORBA_Unbounded_Sequence< TEvent > (_s) {}

    inline TEventSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TEvent > (_max) {}
    inline TEventSeq(_CORBA_ULong _max, _CORBA_ULong _len, TEvent* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TEvent > (_max, _len, _val, _rel) {}

  

    inline TEventSeq& operator = (const TEventSeq& _s) {
      _CORBA_Unbounded_Sequence< TEvent > ::operator=(_s);
      return *this;
    }
  };

  class TEventSeq_out;

  class TEventSeq_var {
  public:
    inline TEventSeq_var() : _pd_seq(0) {}
    inline TEventSeq_var(TEventSeq* _s) : _pd_seq(_s) {}
    inline TEventSeq_var(const TEventSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TEventSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TEventSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TEventSeq_var& operator = (TEventSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TEventSeq_var& operator = (const TEventSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TEventSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TEvent& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TEventSeq* operator -> () { return _pd_seq; }
    inline const TEventSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TEventSeq& () const { return *_pd_seq; }
#else
    inline operator const TEventSeq& () const { return *_pd_seq; }
    inline operator TEventSeq& () { return *_pd_seq; }
#endif
      
    inline const TEventSeq& in() const { return *_pd_seq; }
    inline TEventSeq&       inout()    { return *_pd_seq; }
    inline TEventSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TEventSeq* _retn() { TEventSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TEventSeq_out;
    
  private:
    TEventSeq* _pd_seq;
  };

  class TEventSeq_out {
  public:
    inline TEventSeq_out(TEventSeq*& _s) : _data(_s) { _data = 0; }
    inline TEventSeq_out(TEventSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TEventSeq*) 0; }
    inline TEventSeq_out(const TEventSeq_out& _s) : _data(_s._data) {}
    inline TEventSeq_out& operator = (const TEventSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TEventSeq_out& operator = (TEventSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TEventSeq*&()  { return _data; }
    inline TEventSeq*& ptr()       { return _data; }
    inline TEventSeq* operator->() { return _data; }

    inline TEvent& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TEventSeq*& _data;

  private:
    TEventSeq_out();
    TEventSeq_out& operator=(const TEventSeq_var&);
  };

#ifndef __STI__Client__Server_mParser__
#define __STI__Client__Server_mParser__

  class Parser;
  class _objref_Parser;
  class _impl_Parser;
  
  typedef _objref_Parser* Parser_ptr;
  typedef Parser_ptr ParserRef;

  class Parser_Helper {
  public:
    typedef Parser_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Parser, Parser_Helper> Parser_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Parser,Parser_Helper > Parser_out;

#endif

  // interface Parser
  class Parser {
  public:
    // Declarations for this interface type.
    typedef Parser_ptr _ptr_type;
    typedef Parser_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Parser :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Boolean parseFile(const char* filename);
    ::CORBA::Boolean parseString(const char* code);
    TOverwrittenSeq* overwritten();
    void overwritten(const TOverwrittenSeq& _v);
    ::CORBA::Boolean lockOnParse();
    void lockOnParse(::CORBA::Boolean _v);
    char* outMsg();
    char* errMsg();
    char* mainFile();
    TChannelSeq* channels();
    TStringSeq* files();
    TVariableSeq* variables();
    TEventSeq* events();

    inline _objref_Parser()  { _PR_setobj(0); }  // nil
    _objref_Parser(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Parser();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Parser(const _objref_Parser&);
    _objref_Parser& operator = (const _objref_Parser&);
    // not implemented

    friend class Parser;
  };

  class _pof_Parser : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Parser() : _OMNI_NS(proxyObjectFactory)(Parser::_PD_repoId) {}
    virtual ~_pof_Parser();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Parser :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Parser();

    virtual ::CORBA::Boolean parseFile(const char* filename) = 0;
    virtual ::CORBA::Boolean parseString(const char* code) = 0;
    virtual TOverwrittenSeq* overwritten() = 0;
    virtual void overwritten(const TOverwrittenSeq& _v) = 0;
    virtual ::CORBA::Boolean lockOnParse() = 0;
    virtual void lockOnParse(::CORBA::Boolean _v) = 0;
    virtual char* outMsg() = 0;
    virtual char* errMsg() = 0;
    virtual char* mainFile() = 0;
    virtual TChannelSeq* channels() = 0;
    virtual TStringSeq* files() = 0;
    virtual TVariableSeq* variables() = 0;
    virtual TEventSeq* events() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Parser;

  enum TStatusLevel { LevelStopped, LevelRunning, LevelPaused, LevelError /*, __max_TStatusLevel=0xffffffff */ };
  typedef TStatusLevel& TStatusLevel_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TStatusLevel;

  struct TStatus {
    typedef _CORBA_ConstrType_Fix_Var<TStatus> _var_type;

    
    TStatusLevel level;

    ::CORBA::Double curTime;

    ::CORBA::ULong curEvent;

    ::CORBA::UShort curCycle;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TStatus::_var_type TStatus_var;

  typedef TStatus& TStatus_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TStatus;

  struct TRow {
    typedef _CORBA_ConstrType_Variable_Var<TRow> _var_type;

    
    TStringSeq val;

    ::CORBA::Boolean done;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TRow::_var_type TRow_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TRow,TRow_var > TRow_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TRow;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TRowSeq;

  class TRowSeq_var;

  class TRowSeq : public _CORBA_Unbounded_Sequence< TRow >  {
  public:
    typedef TRowSeq_var _var_type;
    inline TRowSeq() {}
    inline TRowSeq(const TRowSeq& _s)
      : _CORBA_Unbounded_Sequence< TRow > (_s) {}

    inline TRowSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TRow > (_max) {}
    inline TRowSeq(_CORBA_ULong _max, _CORBA_ULong _len, TRow* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TRow > (_max, _len, _val, _rel) {}

  

    inline TRowSeq& operator = (const TRowSeq& _s) {
      _CORBA_Unbounded_Sequence< TRow > ::operator=(_s);
      return *this;
    }
  };

  class TRowSeq_out;

  class TRowSeq_var {
  public:
    inline TRowSeq_var() : _pd_seq(0) {}
    inline TRowSeq_var(TRowSeq* _s) : _pd_seq(_s) {}
    inline TRowSeq_var(const TRowSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TRowSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TRowSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TRowSeq_var& operator = (TRowSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TRowSeq_var& operator = (const TRowSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TRowSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TRow& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TRowSeq* operator -> () { return _pd_seq; }
    inline const TRowSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TRowSeq& () const { return *_pd_seq; }
#else
    inline operator const TRowSeq& () const { return *_pd_seq; }
    inline operator TRowSeq& () { return *_pd_seq; }
#endif
      
    inline const TRowSeq& in() const { return *_pd_seq; }
    inline TRowSeq&       inout()    { return *_pd_seq; }
    inline TRowSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TRowSeq* _retn() { TRowSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TRowSeq_out;
    
  private:
    TRowSeq* _pd_seq;
  };

  class TRowSeq_out {
  public:
    inline TRowSeq_out(TRowSeq*& _s) : _data(_s) { _data = 0; }
    inline TRowSeq_out(TRowSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TRowSeq*) 0; }
    inline TRowSeq_out(const TRowSeq_out& _s) : _data(_s._data) {}
    inline TRowSeq_out& operator = (const TRowSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TRowSeq_out& operator = (TRowSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TRowSeq*&()  { return _data; }
    inline TRowSeq*& ptr()       { return _data; }
    inline TRowSeq* operator->() { return _data; }

    inline TRow& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TRowSeq*& _data;

  private:
    TRowSeq_out();
    TRowSeq_out& operator=(const TRowSeq_var&);
  };

#ifndef __STI__Client__Server_mExpSequence__
#define __STI__Client__Server_mExpSequence__

  class ExpSequence;
  class _objref_ExpSequence;
  class _impl_ExpSequence;
  
  typedef _objref_ExpSequence* ExpSequence_ptr;
  typedef ExpSequence_ptr ExpSequenceRef;

  class ExpSequence_Helper {
  public:
    typedef ExpSequence_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ExpSequence, ExpSequence_Helper> ExpSequence_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ExpSequence,ExpSequence_Helper > ExpSequence_out;

#endif

  // interface ExpSequence
  class ExpSequence {
  public:
    // Declarations for this interface type.
    typedef ExpSequence_ptr _ptr_type;
    typedef ExpSequence_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ExpSequence :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Boolean appendRow(const TStringSeq& newRow);
    ::CORBA::Boolean moveRow(::CORBA::ULong oldPos, ::CORBA::ULong newPos);
    ::CORBA::Boolean editRow(::CORBA::ULong pos, const TStringSeq& newRow);
    void editDone(::CORBA::ULong pos, ::CORBA::Boolean newDone);
    TStringSeq* variables();
    TRowSeq* experiments();

    inline _objref_ExpSequence()  { _PR_setobj(0); }  // nil
    _objref_ExpSequence(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ExpSequence();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ExpSequence(const _objref_ExpSequence&);
    _objref_ExpSequence& operator = (const _objref_ExpSequence&);
    // not implemented

    friend class ExpSequence;
  };

  class _pof_ExpSequence : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ExpSequence() : _OMNI_NS(proxyObjectFactory)(ExpSequence::_PD_repoId) {}
    virtual ~_pof_ExpSequence();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ExpSequence :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ExpSequence();

    virtual ::CORBA::Boolean appendRow(const TStringSeq& newRow) = 0;
    virtual ::CORBA::Boolean moveRow(::CORBA::ULong oldPos, ::CORBA::ULong newPos) = 0;
    virtual ::CORBA::Boolean editRow(::CORBA::ULong pos, const TStringSeq& newRow) = 0;
    virtual void editDone(::CORBA::ULong pos, ::CORBA::Boolean newDone) = 0;
    virtual TStringSeq* variables() = 0;
    virtual TRowSeq* experiments() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExpSequence;

#ifndef __STI__Client__Server_mControl__
#define __STI__Client__Server_mControl__

  class Control;
  class _objref_Control;
  class _impl_Control;
  
  typedef _objref_Control* Control_ptr;
  typedef Control_ptr ControlRef;

  class Control_Helper {
  public:
    typedef Control_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Control, Control_Helper> Control_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Control,Control_Helper > Control_out;

#endif

  // interface Control
  class Control {
  public:
    // Declarations for this interface type.
    typedef Control_ptr _ptr_type;
    typedef Control_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Control :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    TStatus status();
    void reset();
    void setDirect();
    void runSingle();
    void runSequence();
    void _cxx_continue();
    void stop();
    char* errMsg();

    inline _objref_Control()  { _PR_setobj(0); }  // nil
    _objref_Control(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Control();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Control(const _objref_Control&);
    _objref_Control& operator = (const _objref_Control&);
    // not implemented

    friend class Control;
  };

  class _pof_Control : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Control() : _OMNI_NS(proxyObjectFactory)(Control::_PD_repoId) {}
    virtual ~_pof_Control();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Control :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Control();

    virtual TStatus status() = 0;
    virtual void reset() = 0;
    virtual void setDirect() = 0;
    virtual void runSingle() = 0;
    virtual void runSequence() = 0;
    virtual void _cxx_continue() = 0;
    virtual void stop() = 0;
    virtual char* errMsg() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Control;

_CORBA_MODULE_END



_CORBA_MODULE POA_STI_Client_Server
_CORBA_MODULE_BEG

  class ModeHandler :
    public virtual STI_Client_Server::_impl_ModeHandler,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ModeHandler();

    inline ::STI_Client_Server::ModeHandler_ptr _this() {
      return (::STI_Client_Server::ModeHandler_ptr) _do_this(::STI_Client_Server::ModeHandler::_PD_repoId);
    }
  };

  template <class _omniT>
  class ModeHandler_tie : public virtual ModeHandler
  {
  public:
    ModeHandler_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    ModeHandler_tie(_omniT& t, ::PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    ModeHandler_tie(_omniT* t, _CORBA_Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    ModeHandler_tie(_omniT* t, ::PortableServer::POA_ptr p,_CORBA_Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~ModeHandler_tie() {
      if( pd_poa )  ::CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, _CORBA_Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    _CORBA_Boolean _is_owner()        { return pd_rel; }
    void _is_owner(_CORBA_Boolean io) { pd_rel = io;   }

    ::PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return ::PortableServer::POA::_the_root_poa();
      else           return ::PortableServer::POA::_duplicate(pd_poa);
    }

    ::CORBA::Boolean requestControl(const char* myName) { return pd_obj->requestControl(myName); }
    void answerRequest(::CORBA::Boolean yield) { pd_obj->answerRequest(yield); }
    char* controller() { return pd_obj->controller(); }
    void controller(const char* _value) { pd_obj->controller(_value); }
    ::CORBA::Boolean requestPending() { return pd_obj->requestPending(); }
    void requestPending(::CORBA::Boolean _value) { pd_obj->requestPending(_value); }
    char* requesterName() { return pd_obj->requesterName(); }
    void requesterName(const char* _value) { pd_obj->requesterName(_value); }
  

  private:
    _omniT*                   pd_obj;
    ::PortableServer::POA_ptr pd_poa;
    _CORBA_Boolean            pd_rel;
  };

  class Parser :
    public virtual STI_Client_Server::_impl_Parser,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Parser();

    inline ::STI_Client_Server::Parser_ptr _this() {
      return (::STI_Client_Server::Parser_ptr) _do_this(::STI_Client_Server::Parser::_PD_repoId);
    }
  };

  template <class _omniT>
  class Parser_tie : public virtual Parser
  {
  public:
    Parser_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    Parser_tie(_omniT& t, ::PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    Parser_tie(_omniT* t, _CORBA_Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    Parser_tie(_omniT* t, ::PortableServer::POA_ptr p,_CORBA_Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~Parser_tie() {
      if( pd_poa )  ::CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, _CORBA_Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    _CORBA_Boolean _is_owner()        { return pd_rel; }
    void _is_owner(_CORBA_Boolean io) { pd_rel = io;   }

    ::PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return ::PortableServer::POA::_the_root_poa();
      else           return ::PortableServer::POA::_duplicate(pd_poa);
    }

    ::CORBA::Boolean parseFile(const char* filename) { return pd_obj->parseFile(filename); }
    ::CORBA::Boolean parseString(const char* code) { return pd_obj->parseString(code); }
    STI_Client_Server::TOverwrittenSeq* overwritten() { return pd_obj->overwritten(); }
    void overwritten(const STI_Client_Server::TOverwrittenSeq& _value) { pd_obj->overwritten(_value); }
    ::CORBA::Boolean lockOnParse() { return pd_obj->lockOnParse(); }
    void lockOnParse(::CORBA::Boolean _value) { pd_obj->lockOnParse(_value); }
    char* outMsg() { return pd_obj->outMsg(); }
    char* errMsg() { return pd_obj->errMsg(); }
    char* mainFile() { return pd_obj->mainFile(); }
    STI_Client_Server::TChannelSeq* channels() { return pd_obj->channels(); }
    STI_Client_Server::TStringSeq* files() { return pd_obj->files(); }
    STI_Client_Server::TVariableSeq* variables() { return pd_obj->variables(); }
    STI_Client_Server::TEventSeq* events() { return pd_obj->events(); }
  

  private:
    _omniT*                   pd_obj;
    ::PortableServer::POA_ptr pd_poa;
    _CORBA_Boolean            pd_rel;
  };

  class ExpSequence :
    public virtual STI_Client_Server::_impl_ExpSequence,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ExpSequence();

    inline ::STI_Client_Server::ExpSequence_ptr _this() {
      return (::STI_Client_Server::ExpSequence_ptr) _do_this(::STI_Client_Server::ExpSequence::_PD_repoId);
    }
  };

  template <class _omniT>
  class ExpSequence_tie : public virtual ExpSequence
  {
  public:
    ExpSequence_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    ExpSequence_tie(_omniT& t, ::PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    ExpSequence_tie(_omniT* t, _CORBA_Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    ExpSequence_tie(_omniT* t, ::PortableServer::POA_ptr p,_CORBA_Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~ExpSequence_tie() {
      if( pd_poa )  ::CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, _CORBA_Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    _CORBA_Boolean _is_owner()        { return pd_rel; }
    void _is_owner(_CORBA_Boolean io) { pd_rel = io;   }

    ::PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return ::PortableServer::POA::_the_root_poa();
      else           return ::PortableServer::POA::_duplicate(pd_poa);
    }

    ::CORBA::Boolean appendRow(const STI_Client_Server::TStringSeq& newRow) { return pd_obj->appendRow(newRow); }
    ::CORBA::Boolean moveRow(::CORBA::ULong oldPos, ::CORBA::ULong newPos) { return pd_obj->moveRow(oldPos, newPos); }
    ::CORBA::Boolean editRow(::CORBA::ULong pos, const STI_Client_Server::TStringSeq& newRow) { return pd_obj->editRow(pos, newRow); }
    void editDone(::CORBA::ULong pos, ::CORBA::Boolean newDone) { pd_obj->editDone(pos, newDone); }
    STI_Client_Server::TStringSeq* variables() { return pd_obj->variables(); }
    STI_Client_Server::TRowSeq* experiments() { return pd_obj->experiments(); }
  

  private:
    _omniT*                   pd_obj;
    ::PortableServer::POA_ptr pd_poa;
    _CORBA_Boolean            pd_rel;
  };

  class Control :
    public virtual STI_Client_Server::_impl_Control,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Control();

    inline ::STI_Client_Server::Control_ptr _this() {
      return (::STI_Client_Server::Control_ptr) _do_this(::STI_Client_Server::Control::_PD_repoId);
    }
  };

  template <class _omniT>
  class Control_tie : public virtual Control
  {
  public:
    Control_tie(_omniT& t)
      : pd_obj(&t), pd_poa(0), pd_rel(0) {}
    Control_tie(_omniT& t, ::PortableServer::POA_ptr p)
      : pd_obj(&t), pd_poa(p), pd_rel(0) {}
    Control_tie(_omniT* t, _CORBA_Boolean r=1)
      : pd_obj(t), pd_poa(0), pd_rel(r) {}
    Control_tie(_omniT* t, ::PortableServer::POA_ptr p,_CORBA_Boolean r=1)
      : pd_obj(t), pd_poa(p), pd_rel(r) {}
    ~Control_tie() {
      if( pd_poa )  ::CORBA::release(pd_poa);
      if( pd_rel )  delete pd_obj;
    }

    _omniT* _tied_object() { return pd_obj; }

    void _tied_object(_omniT& t) {
      if( pd_rel )  delete pd_obj;
      pd_obj = &t;
      pd_rel = 0;
    }

    void _tied_object(_omniT* t, _CORBA_Boolean r=1) {
      if( pd_rel )  delete pd_obj;
      pd_obj = t;
      pd_rel = r;
    }

    _CORBA_Boolean _is_owner()        { return pd_rel; }
    void _is_owner(_CORBA_Boolean io) { pd_rel = io;   }

    ::PortableServer::POA_ptr _default_POA() {
      if( !pd_poa )  return ::PortableServer::POA::_the_root_poa();
      else           return ::PortableServer::POA::_duplicate(pd_poa);
    }

    STI_Client_Server::TStatus status() { return pd_obj->status(); }
    void reset() { pd_obj->reset(); }
    void setDirect() { pd_obj->setDirect(); }
    void runSingle() { pd_obj->runSingle(); }
    void runSequence() { pd_obj->runSequence(); }
    void _cxx_continue() { pd_obj->_cxx_continue(); }
    void stop() { pd_obj->stop(); }
    char* errMsg() { return pd_obj->errMsg(); }
  

  private:
    _omniT*                   pd_obj;
    ::PortableServer::POA_ptr pd_poa;
    _CORBA_Boolean            pd_rel;
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_STI_Client_Server
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TOverwritten& _s);
extern void operator<<=(::CORBA::Any& _a, STI_Client_Server::TOverwritten* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TOverwritten*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TOverwritten*& _sp);

extern void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TDevice& _s);
extern void operator<<=(::CORBA::Any& _a, STI_Client_Server::TDevice* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TDevice*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TDevice*& _sp);

extern void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TChannel& _s);
extern void operator<<=(::CORBA::Any& _a, STI_Client_Server::TChannel* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TChannel*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TChannel*& _sp);

inline void operator >>=(STI_Client_Server::TType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Client_Server::TType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Client_Server::TypeObject) {
    _e = (STI_Client_Server::TType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, STI_Client_Server::TType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TType& _s);

void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TVarMixed& _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::TVarMixed* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TVarMixed*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TVarMixed*& _sp);

extern void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TPosition& _s);
extern void operator<<=(::CORBA::Any& _a, STI_Client_Server::TPosition* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TPosition*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TPosition*& _sp);

extern void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TVariable& _s);
extern void operator<<=(::CORBA::Any& _a, STI_Client_Server::TVariable* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TVariable*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TVariable*& _sp);

extern void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TDDS& _s);
extern void operator<<=(::CORBA::Any& _a, STI_Client_Server::TDDS* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TDDS*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TDDS*& _sp);

inline void operator >>=(STI_Client_Server::TValue _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Client_Server::TValue& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Client_Server::ValueDDSTriplet) {
    _e = (STI_Client_Server::TValue) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, STI_Client_Server::TValue _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TValue& _s);

void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TValMixed& _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::TValMixed* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TValMixed*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TValMixed*& _sp);

extern void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TEvent& _s);
extern void operator<<=(::CORBA::Any& _a, STI_Client_Server::TEvent* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TEvent*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TEvent*& _sp);

void operator<<=(::CORBA::Any& _a, STI_Client_Server::ModeHandler_ptr _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::ModeHandler_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::ModeHandler_ptr& _s);

void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TOverwrittenSeq& _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::TOverwrittenSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TOverwrittenSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TOverwrittenSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TChannelSeq& _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::TChannelSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TChannelSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TChannelSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TStringSeq& _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::TStringSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TStringSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TStringSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TVariableSeq& _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::TVariableSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TVariableSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TVariableSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TEventSeq& _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::TEventSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TEventSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TEventSeq*& _sp);

void operator<<=(::CORBA::Any& _a, STI_Client_Server::Parser_ptr _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::Parser_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::Parser_ptr& _s);

inline void operator >>=(STI_Client_Server::TStatusLevel _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Client_Server::TStatusLevel& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Client_Server::LevelError) {
    _e = (STI_Client_Server::TStatusLevel) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, STI_Client_Server::TStatusLevel _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TStatusLevel& _s);

extern void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TStatus& _s);
extern void operator<<=(::CORBA::Any& _a, STI_Client_Server::TStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TStatus*& _sp);

extern void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TRow& _s);
extern void operator<<=(::CORBA::Any& _a, STI_Client_Server::TRow* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TRow*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TRow*& _sp);

void operator<<=(::CORBA::Any& _a, const STI_Client_Server::TRowSeq& _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::TRowSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::TRowSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const STI_Client_Server::TRowSeq*& _sp);

void operator<<=(::CORBA::Any& _a, STI_Client_Server::ExpSequence_ptr _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::ExpSequence_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::ExpSequence_ptr& _s);

void operator<<=(::CORBA::Any& _a, STI_Client_Server::Control_ptr _s);
void operator<<=(::CORBA::Any& _a, STI_Client_Server::Control_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, STI_Client_Server::Control_ptr& _s);



inline void
STI_Client_Server::ModeHandler::_marshalObjRef(::STI_Client_Server::ModeHandler_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Client_Server::Parser::_marshalObjRef(::STI_Client_Server::Parser_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Client_Server::ExpSequence::_marshalObjRef(::STI_Client_Server::ExpSequence_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Client_Server::Control::_marshalObjRef(::STI_Client_Server::Control_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_client
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_client
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_client
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_client
#endif

#endif  // __client_hh__

