// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __device_hh__
#define __device_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE STI_Server_Device

_CORBA_MODULE_BEG

  class TStringSeq_var;

  class TStringSeq : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef TStringSeq_var _var_type;
    inline TStringSeq() {}
    inline TStringSeq(const TStringSeq& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline TStringSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline TStringSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline TStringSeq& operator = (const TStringSeq& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class TStringSeq_out;

  class TStringSeq_var {
  public:
    inline TStringSeq_var() : _pd_seq(0) {}
    inline TStringSeq_var(TStringSeq* _s) : _pd_seq(_s) {}
    inline TStringSeq_var(const TStringSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TStringSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TStringSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TStringSeq_var& operator = (TStringSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TStringSeq_var& operator = (const TStringSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TStringSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TStringSeq* operator -> () { return _pd_seq; }
    inline const TStringSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TStringSeq& () const { return *_pd_seq; }
#else
    inline operator const TStringSeq& () const { return *_pd_seq; }
    inline operator TStringSeq& () { return *_pd_seq; }
#endif
      
    inline const TStringSeq& in() const { return *_pd_seq; }
    inline TStringSeq&       inout()    { return *_pd_seq; }
    inline TStringSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TStringSeq* _retn() { TStringSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TStringSeq_out;
    
  private:
    TStringSeq* _pd_seq;
  };

  class TStringSeq_out {
  public:
    inline TStringSeq_out(TStringSeq*& _s) : _data(_s) { _data = 0; }
    inline TStringSeq_out(TStringSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TStringSeq*) 0; }
    inline TStringSeq_out(const TStringSeq_out& _s) : _data(_s._data) {}
    inline TStringSeq_out& operator = (const TStringSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TStringSeq_out& operator = (TStringSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TStringSeq*&()  { return _data; }
    inline TStringSeq*& ptr()       { return _data; }
    inline TStringSeq* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TStringSeq*& _data;

  private:
    TStringSeq_out();
    TStringSeq_out& operator=(const TStringSeq_var&);
  };

  struct TAttribute {
    typedef _CORBA_ConstrType_Variable_Var<TAttribute> _var_type;

    
    ::CORBA::String_member key;

    ::CORBA::String_member value;

    TStringSeq values;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TAttribute::_var_type TAttribute_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TAttribute,TAttribute_var > TAttribute_out;

  class TAttributeSeq_var;

  class TAttributeSeq : public _CORBA_Unbounded_Sequence< TAttribute >  {
  public:
    typedef TAttributeSeq_var _var_type;
    inline TAttributeSeq() {}
    inline TAttributeSeq(const TAttributeSeq& _s)
      : _CORBA_Unbounded_Sequence< TAttribute > (_s) {}

    inline TAttributeSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TAttribute > (_max) {}
    inline TAttributeSeq(_CORBA_ULong _max, _CORBA_ULong _len, TAttribute* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TAttribute > (_max, _len, _val, _rel) {}

  

    inline TAttributeSeq& operator = (const TAttributeSeq& _s) {
      _CORBA_Unbounded_Sequence< TAttribute > ::operator=(_s);
      return *this;
    }
  };

  class TAttributeSeq_out;

  class TAttributeSeq_var {
  public:
    inline TAttributeSeq_var() : _pd_seq(0) {}
    inline TAttributeSeq_var(TAttributeSeq* _s) : _pd_seq(_s) {}
    inline TAttributeSeq_var(const TAttributeSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TAttributeSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TAttributeSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TAttributeSeq_var& operator = (TAttributeSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TAttributeSeq_var& operator = (const TAttributeSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TAttributeSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TAttribute& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TAttributeSeq* operator -> () { return _pd_seq; }
    inline const TAttributeSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TAttributeSeq& () const { return *_pd_seq; }
#else
    inline operator const TAttributeSeq& () const { return *_pd_seq; }
    inline operator TAttributeSeq& () { return *_pd_seq; }
#endif
      
    inline const TAttributeSeq& in() const { return *_pd_seq; }
    inline TAttributeSeq&       inout()    { return *_pd_seq; }
    inline TAttributeSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TAttributeSeq* _retn() { TAttributeSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TAttributeSeq_out;
    
  private:
    TAttributeSeq* _pd_seq;
  };

  class TAttributeSeq_out {
  public:
    inline TAttributeSeq_out(TAttributeSeq*& _s) : _data(_s) { _data = 0; }
    inline TAttributeSeq_out(TAttributeSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TAttributeSeq*) 0; }
    inline TAttributeSeq_out(const TAttributeSeq_out& _s) : _data(_s._data) {}
    inline TAttributeSeq_out& operator = (const TAttributeSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TAttributeSeq_out& operator = (TAttributeSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TAttributeSeq*&()  { return _data; }
    inline TAttributeSeq*& ptr()       { return _data; }
    inline TAttributeSeq* operator->() { return _data; }

    inline TAttribute& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TAttributeSeq*& _data;

  private:
    TAttributeSeq_out();
    TAttributeSeq_out& operator=(const TAttributeSeq_var&);
  };

#ifndef __STI__Server__Device_mConfigure__
#define __STI__Server__Device_mConfigure__

  class Configure;
  class _objref_Configure;
  class _impl_Configure;
  
  typedef _objref_Configure* Configure_ptr;
  typedef Configure_ptr ConfigureRef;

  class Configure_Helper {
  public:
    typedef Configure_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Configure, Configure_Helper> Configure_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Configure,Configure_Helper > Configure_out;

#endif

  // interface Configure
  class Configure {
  public:
    // Declarations for this interface type.
    typedef Configure_ptr _ptr_type;
    typedef Configure_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Configure :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Boolean setAttribute(const char* key, const char* value);
    char* getAttribute(const char* key);
    TAttributeSeq* attributes();
    char* deviceType();

    inline _objref_Configure()  { _PR_setobj(0); }  // nil
    _objref_Configure(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Configure();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Configure(const _objref_Configure&);
    _objref_Configure& operator = (const _objref_Configure&);
    // not implemented

    friend class Configure;
  };

  class _pof_Configure : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Configure() : _OMNI_NS(proxyObjectFactory)(Configure::_PD_repoId) {}
    virtual ~_pof_Configure();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Configure :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Configure();

    virtual ::CORBA::Boolean setAttribute(const char* key, const char* value) = 0;
    virtual char* getAttribute(const char* key) = 0;
    virtual TAttributeSeq* attributes() = 0;
    virtual char* deviceType() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  struct TDDS {
    typedef _CORBA_ConstrType_Fix_Var<TDDS> _var_type;

    
    ::CORBA::Double freq;

    ::CORBA::Double phase;

    ::CORBA::Double ampl;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDDS::_var_type TDDS_var;

  typedef TDDS& TDDS_out;

  enum TValue { ValueNumber, ValueString, ValueDDSTriplet, ValueMeas /*, __max_TValue=0xffffffff */ };
  typedef TValue& TValue_out;

  class TValMixed {
  public:

    typedef _CORBA_ConstrType_Variable_Var<TValMixed> _var_type;

    

    TValMixed(): _pd__initialised(0) {
      
    }
    
    TValMixed(const TValMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case ValueNumber: number(_value._pd_number); break;

        case ValueString: stringVal(_value._pd_stringVal); break;

        case ValueDDSTriplet: triplet(_value._pd_triplet); break;

        case ValueMeas: meas(_value._pd_meas); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
    }

    ~TValMixed() {}

    TValMixed& operator=(const TValMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      switch(_value._pd__d) {
        case ValueNumber: number(_value._pd_number); break;

        case ValueString: stringVal(_value._pd_stringVal); break;

        case ValueDDSTriplet: triplet(_value._pd_triplet); break;

        case ValueMeas: meas(_value._pd_meas); break;

          default: break;

      
      }
      _pd__d = _value._pd__d;
  
      return *this;
    }

    TValue _d() const { return _pd__d;}
    void _d(TValue _value){
      // illegal to set discriminator before making a member active
      if (!_pd__initialised)
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

      if (_value == _pd__d) return; // no change

      switch (_pd__d){
        case ValueNumber: goto fail;
        case ValueString: goto fail;
        case ValueDDSTriplet: goto fail;
        case ValueMeas: goto fail;
        default: goto fail;

      };
      

      fail:
      OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


  
    }

    

    ::CORBA::Double number () const { return _pd_number; }
    void number (::CORBA::Double  _value) {
      _pd__initialised = 1;
      _pd__d = ValueNumber;
      _pd__default = 0;
      _pd_number = _value;
    }

    const char * stringVal () const { return (const char*) _pd_stringVal; }
    void stringVal(char* _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const char*  _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_var& _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_member& _value) {
      _pd__initialised = 1;
      _pd__d = ValueString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }

    const TDDS &triplet () const { return _pd_triplet; }
    TDDS &triplet () { return _pd_triplet; }
    void triplet (const TDDS& _value) {
      _pd__initialised = 1;
      _pd__d = ValueDDSTriplet;
      _pd__default = 0;
      _pd_triplet = _value;
    }

    ::CORBA::Boolean meas () const { return _pd_meas; }
    void meas (::CORBA::Boolean  _value) {
      _pd__initialised = 1;
      _pd__d = ValueMeas;
      _pd__default = 0;
      _pd_meas = _value;
    }

  
    
    void operator>>= (cdrStream&) const;
    void operator<<= (cdrStream&);

  private:
    TValue _pd__d;
    _CORBA_Boolean _pd__default;
    _CORBA_Boolean _pd__initialised;

    union {
      
#ifndef USING_PROXY_FLOAT
        ::CORBA::Double _pd_number;
#endif

      ::CORBA::Boolean _pd_meas;


    };

  
    
#ifdef USING_PROXY_FLOAT
      ::CORBA::Double _pd_number;
#endif

    ::CORBA::String_member _pd_stringVal;

    TDDS _pd_triplet;

  
  };

  typedef TValMixed::_var_type TValMixed_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TValMixed,TValMixed_var > TValMixed_out;

  struct TDeviceEvent {
    typedef _CORBA_ConstrType_Variable_Var<TDeviceEvent> _var_type;

    
    ::CORBA::UShort channel;

    ::CORBA::Double time;

    TValMixed value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDeviceEvent::_var_type TDeviceEvent_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TDeviceEvent,TDeviceEvent_var > TDeviceEvent_out;

  class TDeviceEventSeq_var;

  class TDeviceEventSeq : public _CORBA_Unbounded_Sequence< TDeviceEvent >  {
  public:
    typedef TDeviceEventSeq_var _var_type;
    inline TDeviceEventSeq() {}
    inline TDeviceEventSeq(const TDeviceEventSeq& _s)
      : _CORBA_Unbounded_Sequence< TDeviceEvent > (_s) {}

    inline TDeviceEventSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TDeviceEvent > (_max) {}
    inline TDeviceEventSeq(_CORBA_ULong _max, _CORBA_ULong _len, TDeviceEvent* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TDeviceEvent > (_max, _len, _val, _rel) {}

  

    inline TDeviceEventSeq& operator = (const TDeviceEventSeq& _s) {
      _CORBA_Unbounded_Sequence< TDeviceEvent > ::operator=(_s);
      return *this;
    }
  };

  class TDeviceEventSeq_out;

  class TDeviceEventSeq_var {
  public:
    inline TDeviceEventSeq_var() : _pd_seq(0) {}
    inline TDeviceEventSeq_var(TDeviceEventSeq* _s) : _pd_seq(_s) {}
    inline TDeviceEventSeq_var(const TDeviceEventSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TDeviceEventSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TDeviceEventSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TDeviceEventSeq_var& operator = (TDeviceEventSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TDeviceEventSeq_var& operator = (const TDeviceEventSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TDeviceEventSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TDeviceEvent& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TDeviceEventSeq* operator -> () { return _pd_seq; }
    inline const TDeviceEventSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TDeviceEventSeq& () const { return *_pd_seq; }
#else
    inline operator const TDeviceEventSeq& () const { return *_pd_seq; }
    inline operator TDeviceEventSeq& () { return *_pd_seq; }
#endif
      
    inline const TDeviceEventSeq& in() const { return *_pd_seq; }
    inline TDeviceEventSeq&       inout()    { return *_pd_seq; }
    inline TDeviceEventSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TDeviceEventSeq* _retn() { TDeviceEventSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TDeviceEventSeq_out;
    
  private:
    TDeviceEventSeq* _pd_seq;
  };

  class TDeviceEventSeq_out {
  public:
    inline TDeviceEventSeq_out(TDeviceEventSeq*& _s) : _data(_s) { _data = 0; }
    inline TDeviceEventSeq_out(TDeviceEventSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TDeviceEventSeq*) 0; }
    inline TDeviceEventSeq_out(const TDeviceEventSeq_out& _s) : _data(_s._data) {}
    inline TDeviceEventSeq_out& operator = (const TDeviceEventSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TDeviceEventSeq_out& operator = (TDeviceEventSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TDeviceEventSeq*&()  { return _data; }
    inline TDeviceEventSeq*& ptr()       { return _data; }
    inline TDeviceEventSeq* operator->() { return _data; }

    inline TDeviceEvent& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TDeviceEventSeq*& _data;

  private:
    TDeviceEventSeq_out();
    TDeviceEventSeq_out& operator=(const TDeviceEventSeq_var&);
  };

  class TshortSeq_var;

  class TshortSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 >  {
  public:
    typedef TshortSeq_var _var_type;
    inline TshortSeq() {}
    inline TshortSeq(const TshortSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_s) {}

    inline TshortSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max) {}
    inline TshortSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::UShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline TshortSeq& operator = (const TshortSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class TshortSeq_out;

  class TshortSeq_var {
  public:
    inline TshortSeq_var() : _pd_seq(0) {}
    inline TshortSeq_var(TshortSeq* _s) : _pd_seq(_s) {}
    inline TshortSeq_var(const TshortSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TshortSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TshortSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TshortSeq_var& operator = (TshortSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TshortSeq_var& operator = (const TshortSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TshortSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::UShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TshortSeq* operator -> () { return _pd_seq; }
    inline const TshortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TshortSeq& () const { return *_pd_seq; }
#else
    inline operator const TshortSeq& () const { return *_pd_seq; }
    inline operator TshortSeq& () { return *_pd_seq; }
#endif
      
    inline const TshortSeq& in() const { return *_pd_seq; }
    inline TshortSeq&       inout()    { return *_pd_seq; }
    inline TshortSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TshortSeq* _retn() { TshortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TshortSeq_out;
    
  private:
    TshortSeq* _pd_seq;
  };

  class TshortSeq_out {
  public:
    inline TshortSeq_out(TshortSeq*& _s) : _data(_s) { _data = 0; }
    inline TshortSeq_out(TshortSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TshortSeq*) 0; }
    inline TshortSeq_out(const TshortSeq_out& _s) : _data(_s._data) {}
    inline TshortSeq_out& operator = (const TshortSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TshortSeq_out& operator = (TshortSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TshortSeq*&()  { return _data; }
    inline TshortSeq*& ptr()       { return _data; }
    inline TshortSeq* operator->() { return _data; }

    inline ::CORBA::UShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TshortSeq*& _data;

  private:
    TshortSeq_out();
    TshortSeq_out& operator=(const TshortSeq_var&);
  };

  struct TPicture {
    typedef _CORBA_ConstrType_Variable_Var<TPicture> _var_type;

    
    ::CORBA::UShort rowLength;

    TshortSeq pixels;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TPicture::_var_type TPicture_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TPicture,TPicture_var > TPicture_out;

  enum TData { DataNumber, DataString, DataPicture, DataNone /*, __max_TData=0xffffffff */ };
  typedef TData& TData_out;

  class TDataMixed {
  public:

    typedef _CORBA_ConstrType_Variable_Var<TDataMixed> _var_type;

    

    TDataMixed(): _pd__initialised(0) {
      _default();

  
    }
    
    TDataMixed(const TDataMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      if ((_pd__default = _value._pd__default)) {
        
      }
      else {
        switch(_value._pd__d) {
          case DataNumber: number(_value._pd_number); break;

          case DataString: stringVal(_value._pd_stringVal); break;

          case DataPicture: picture(_value._pd_picture); break;

            default: break;

      
        }
      }
      _pd__d = _value._pd__d;

  
    }

    ~TDataMixed() {}

    TDataMixed& operator=(const TDataMixed& _value) {
      _pd__initialised = _value._pd__initialised;
      if ((_pd__default = _value._pd__default)) {
        
      }
      else {
        switch(_value._pd__d) {
          case DataNumber: number(_value._pd_number); break;

          case DataString: stringVal(_value._pd_stringVal); break;

          case DataPicture: picture(_value._pd_picture); break;

            default: break;

      
        }
      }
      _pd__d = _value._pd__d;

  
      return *this;
    }

    TData _d() const { return _pd__d;}
    void _d(TData _value){
      // illegal to set discriminator before making a member active
      if (!_pd__initialised)
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

      if (_value == _pd__d) return; // no change

      switch (_pd__d){
        case DataNumber: goto fail;
        case DataString: goto fail;
        case DataPicture: goto fail;
        default:
        switch (_value){
          case DataNumber: goto fail;
          case DataString: goto fail;
          case DataPicture: goto fail;
          default: _pd__d = _value; return;
        }

      };
      

      fail:
      OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


  
    }

    void _default()
    {
      _pd__initialised = 1;
      _pd__d = DataNone;
      _pd__default = 1;
    }

  

    ::CORBA::Double number () const { return _pd_number; }
    void number (::CORBA::Double  _value) {
      _pd__initialised = 1;
      _pd__d = DataNumber;
      _pd__default = 0;
      _pd_number = _value;
    }

    const char * stringVal () const { return (const char*) _pd_stringVal; }
    void stringVal(char* _value) {
      _pd__initialised = 1;
      _pd__d = DataString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const char*  _value) {
      _pd__initialised = 1;
      _pd__d = DataString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_var& _value) {
      _pd__initialised = 1;
      _pd__d = DataString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }
    void stringVal(const ::CORBA::String_member& _value) {
      _pd__initialised = 1;
      _pd__d = DataString;
      _pd__default = 0;
      _pd_stringVal = _value;
    }

    const TPicture &picture () const { return _pd_picture; }
    TPicture &picture () { return _pd_picture; }
    void picture (const TPicture& _value) {
      _pd__initialised = 1;
      _pd__d = DataPicture;
      _pd__default = 0;
      _pd_picture = _value;
    }

  
    
    void operator>>= (cdrStream&) const;
    void operator<<= (cdrStream&);

  private:
    TData _pd__d;
    _CORBA_Boolean _pd__default;
    _CORBA_Boolean _pd__initialised;

    union {
      
#ifndef USING_PROXY_FLOAT
        ::CORBA::Double _pd_number;
#endif


    };

  
    
#ifdef USING_PROXY_FLOAT
      ::CORBA::Double _pd_number;
#endif

    ::CORBA::String_member _pd_stringVal;

    TPicture _pd_picture;

  
  };

  typedef TDataMixed::_var_type TDataMixed_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TDataMixed,TDataMixed_var > TDataMixed_out;

  struct TMeasurement {
    typedef _CORBA_ConstrType_Variable_Var<TMeasurement> _var_type;

    
    ::CORBA::Double time;

    TDataMixed data;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TMeasurement::_var_type TMeasurement_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TMeasurement,TMeasurement_var > TMeasurement_out;

  class TMeasurementSeq_var;

  class TMeasurementSeq : public _CORBA_Unbounded_Sequence< TMeasurement >  {
  public:
    typedef TMeasurementSeq_var _var_type;
    inline TMeasurementSeq() {}
    inline TMeasurementSeq(const TMeasurementSeq& _s)
      : _CORBA_Unbounded_Sequence< TMeasurement > (_s) {}

    inline TMeasurementSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TMeasurement > (_max) {}
    inline TMeasurementSeq(_CORBA_ULong _max, _CORBA_ULong _len, TMeasurement* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TMeasurement > (_max, _len, _val, _rel) {}

  

    inline TMeasurementSeq& operator = (const TMeasurementSeq& _s) {
      _CORBA_Unbounded_Sequence< TMeasurement > ::operator=(_s);
      return *this;
    }
  };

  class TMeasurementSeq_out;

  class TMeasurementSeq_var {
  public:
    inline TMeasurementSeq_var() : _pd_seq(0) {}
    inline TMeasurementSeq_var(TMeasurementSeq* _s) : _pd_seq(_s) {}
    inline TMeasurementSeq_var(const TMeasurementSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TMeasurementSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TMeasurementSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TMeasurementSeq_var& operator = (TMeasurementSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TMeasurementSeq_var& operator = (const TMeasurementSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TMeasurementSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TMeasurement& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TMeasurementSeq* operator -> () { return _pd_seq; }
    inline const TMeasurementSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TMeasurementSeq& () const { return *_pd_seq; }
#else
    inline operator const TMeasurementSeq& () const { return *_pd_seq; }
    inline operator TMeasurementSeq& () { return *_pd_seq; }
#endif
      
    inline const TMeasurementSeq& in() const { return *_pd_seq; }
    inline TMeasurementSeq&       inout()    { return *_pd_seq; }
    inline TMeasurementSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TMeasurementSeq* _retn() { TMeasurementSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TMeasurementSeq_out;
    
  private:
    TMeasurementSeq* _pd_seq;
  };

  class TMeasurementSeq_out {
  public:
    inline TMeasurementSeq_out(TMeasurementSeq*& _s) : _data(_s) { _data = 0; }
    inline TMeasurementSeq_out(TMeasurementSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TMeasurementSeq*) 0; }
    inline TMeasurementSeq_out(const TMeasurementSeq_out& _s) : _data(_s._data) {}
    inline TMeasurementSeq_out& operator = (const TMeasurementSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TMeasurementSeq_out& operator = (TMeasurementSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TMeasurementSeq*&()  { return _data; }
    inline TMeasurementSeq*& ptr()       { return _data; }
    inline TMeasurementSeq* operator->() { return _data; }

    inline TMeasurement& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TMeasurementSeq*& _data;

  private:
    TMeasurementSeq_out();
    TMeasurementSeq_out& operator=(const TMeasurementSeq_var&);
  };

  class TMeasurementSeqSeq_var;

  class TMeasurementSeqSeq : public _CORBA_Unbounded_Sequence< TMeasurementSeq >  {
  public:
    typedef TMeasurementSeqSeq_var _var_type;
    inline TMeasurementSeqSeq() {}
    inline TMeasurementSeqSeq(const TMeasurementSeqSeq& _s)
      : _CORBA_Unbounded_Sequence< TMeasurementSeq > (_s) {}

    inline TMeasurementSeqSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TMeasurementSeq > (_max) {}
    inline TMeasurementSeqSeq(_CORBA_ULong _max, _CORBA_ULong _len, TMeasurementSeq* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TMeasurementSeq > (_max, _len, _val, _rel) {}

  

    inline TMeasurementSeqSeq& operator = (const TMeasurementSeqSeq& _s) {
      _CORBA_Unbounded_Sequence< TMeasurementSeq > ::operator=(_s);
      return *this;
    }
  };

  class TMeasurementSeqSeq_out;

  class TMeasurementSeqSeq_var {
  public:
    inline TMeasurementSeqSeq_var() : _pd_seq(0) {}
    inline TMeasurementSeqSeq_var(TMeasurementSeqSeq* _s) : _pd_seq(_s) {}
    inline TMeasurementSeqSeq_var(const TMeasurementSeqSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TMeasurementSeqSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TMeasurementSeqSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TMeasurementSeqSeq_var& operator = (TMeasurementSeqSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TMeasurementSeqSeq_var& operator = (const TMeasurementSeqSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TMeasurementSeqSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TMeasurementSeq& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TMeasurementSeqSeq* operator -> () { return _pd_seq; }
    inline const TMeasurementSeqSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TMeasurementSeqSeq& () const { return *_pd_seq; }
#else
    inline operator const TMeasurementSeqSeq& () const { return *_pd_seq; }
    inline operator TMeasurementSeqSeq& () { return *_pd_seq; }
#endif
      
    inline const TMeasurementSeqSeq& in() const { return *_pd_seq; }
    inline TMeasurementSeqSeq&       inout()    { return *_pd_seq; }
    inline TMeasurementSeqSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TMeasurementSeqSeq* _retn() { TMeasurementSeqSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TMeasurementSeqSeq_out;
    
  private:
    TMeasurementSeqSeq* _pd_seq;
  };

  class TMeasurementSeqSeq_out {
  public:
    inline TMeasurementSeqSeq_out(TMeasurementSeqSeq*& _s) : _data(_s) { _data = 0; }
    inline TMeasurementSeqSeq_out(TMeasurementSeqSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TMeasurementSeqSeq*) 0; }
    inline TMeasurementSeqSeq_out(const TMeasurementSeqSeq_out& _s) : _data(_s._data) {}
    inline TMeasurementSeqSeq_out& operator = (const TMeasurementSeqSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TMeasurementSeqSeq_out& operator = (TMeasurementSeqSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TMeasurementSeqSeq*&()  { return _data; }
    inline TMeasurementSeqSeq*& ptr()       { return _data; }
    inline TMeasurementSeqSeq* operator->() { return _data; }

    inline TMeasurementSeq& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TMeasurementSeqSeq*& _data;

  private:
    TMeasurementSeqSeq_out();
    TMeasurementSeqSeq_out& operator=(const TMeasurementSeqSeq_var&);
  };

#ifndef __STI__Server__Device_mDataTransfer__
#define __STI__Server__Device_mDataTransfer__

  class DataTransfer;
  class _objref_DataTransfer;
  class _impl_DataTransfer;
  
  typedef _objref_DataTransfer* DataTransfer_ptr;
  typedef DataTransfer_ptr DataTransferRef;

  class DataTransfer_Helper {
  public:
    typedef DataTransfer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DataTransfer, DataTransfer_Helper> DataTransfer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DataTransfer,DataTransfer_Helper > DataTransfer_out;

#endif

  // interface DataTransfer
  class DataTransfer {
  public:
    // Declarations for this interface type.
    typedef DataTransfer_ptr _ptr_type;
    typedef DataTransfer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_DataTransfer :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    char* errMsg();
    TMeasurementSeqSeq* measurements();

    inline _objref_DataTransfer()  { _PR_setobj(0); }  // nil
    _objref_DataTransfer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DataTransfer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DataTransfer(const _objref_DataTransfer&);
    _objref_DataTransfer& operator = (const _objref_DataTransfer&);
    // not implemented

    friend class DataTransfer;
  };

  class _pof_DataTransfer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DataTransfer() : _OMNI_NS(proxyObjectFactory)(DataTransfer::_PD_repoId) {}
    virtual ~_pof_DataTransfer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DataTransfer :
    public virtual omniServant
  {
  public:
    virtual ~_impl_DataTransfer();

    virtual char* errMsg() = 0;
    virtual TMeasurementSeqSeq* measurements() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  enum TStatusLevel { LevelStopped, LevelRunning, LevelPaused, LevelError /*, __max_TStatusLevel=0xffffffff */ };
  typedef TStatusLevel& TStatusLevel_out;

  struct TStatus {
    typedef _CORBA_ConstrType_Fix_Var<TStatus> _var_type;

    
    TStatusLevel level;

    ::CORBA::Double curTime;

    ::CORBA::ULong curEvent;

    ::CORBA::UShort curCycle;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TStatus::_var_type TStatus_var;

  typedef TStatus& TStatus_out;

#ifndef __STI__Server__Device_mDeviceControl__
#define __STI__Server__Device_mDeviceControl__

  class DeviceControl;
  class _objref_DeviceControl;
  class _impl_DeviceControl;
  
  typedef _objref_DeviceControl* DeviceControl_ptr;
  typedef DeviceControl_ptr DeviceControlRef;

  class DeviceControl_Helper {
  public:
    typedef DeviceControl_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DeviceControl, DeviceControl_Helper> DeviceControl_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceControl,DeviceControl_Helper > DeviceControl_out;

#endif

  // interface DeviceControl
  class DeviceControl {
  public:
    // Declarations for this interface type.
    typedef DeviceControl_ptr _ptr_type;
    typedef DeviceControl_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_DeviceControl :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    TStatus status();
    ::CORBA::Boolean transferEvents(const TDeviceEventSeq& events, ::CORBA::Boolean dryrun);
    void reset();
    void start();
    void trigger();
    void stop();
    char* errMsg();

    inline _objref_DeviceControl()  { _PR_setobj(0); }  // nil
    _objref_DeviceControl(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DeviceControl();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DeviceControl(const _objref_DeviceControl&);
    _objref_DeviceControl& operator = (const _objref_DeviceControl&);
    // not implemented

    friend class DeviceControl;
  };

  class _pof_DeviceControl : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DeviceControl() : _OMNI_NS(proxyObjectFactory)(DeviceControl::_PD_repoId) {}
    virtual ~_pof_DeviceControl();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DeviceControl :
    public virtual omniServant
  {
  public:
    virtual ~_impl_DeviceControl();

    virtual TStatus status() = 0;
    virtual ::CORBA::Boolean transferEvents(const TDeviceEventSeq& events, ::CORBA::Boolean dryrun) = 0;
    virtual void reset() = 0;
    virtual void start() = 0;
    virtual void trigger() = 0;
    virtual void stop() = 0;
    virtual char* errMsg() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  enum TChannelType { Output, Input, BiDirectional /*, __max_TChannelType=0xffffffff */ };
  typedef TChannelType& TChannelType_out;

  struct TDeviceChannel {
    typedef _CORBA_ConstrType_Fix_Var<TDeviceChannel> _var_type;

    
    ::CORBA::UShort channel;

    TChannelType type;

    TData inputType;

    TValue outputType;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDeviceChannel::_var_type TDeviceChannel_var;

  typedef TDeviceChannel& TDeviceChannel_out;

  class TDeviceChannelSeq_var;

  class TDeviceChannelSeq : public _CORBA_Unbounded_Sequence< TDeviceChannel >  {
  public:
    typedef TDeviceChannelSeq_var _var_type;
    inline TDeviceChannelSeq() {}
    inline TDeviceChannelSeq(const TDeviceChannelSeq& _s)
      : _CORBA_Unbounded_Sequence< TDeviceChannel > (_s) {}

    inline TDeviceChannelSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< TDeviceChannel > (_max) {}
    inline TDeviceChannelSeq(_CORBA_ULong _max, _CORBA_ULong _len, TDeviceChannel* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< TDeviceChannel > (_max, _len, _val, _rel) {}

  

    inline TDeviceChannelSeq& operator = (const TDeviceChannelSeq& _s) {
      _CORBA_Unbounded_Sequence< TDeviceChannel > ::operator=(_s);
      return *this;
    }
  };

  class TDeviceChannelSeq_out;

  class TDeviceChannelSeq_var {
  public:
    inline TDeviceChannelSeq_var() : _pd_seq(0) {}
    inline TDeviceChannelSeq_var(TDeviceChannelSeq* _s) : _pd_seq(_s) {}
    inline TDeviceChannelSeq_var(const TDeviceChannelSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TDeviceChannelSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TDeviceChannelSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TDeviceChannelSeq_var& operator = (TDeviceChannelSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TDeviceChannelSeq_var& operator = (const TDeviceChannelSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TDeviceChannelSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TDeviceChannel& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TDeviceChannelSeq* operator -> () { return _pd_seq; }
    inline const TDeviceChannelSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TDeviceChannelSeq& () const { return *_pd_seq; }
#else
    inline operator const TDeviceChannelSeq& () const { return *_pd_seq; }
    inline operator TDeviceChannelSeq& () { return *_pd_seq; }
#endif
      
    inline const TDeviceChannelSeq& in() const { return *_pd_seq; }
    inline TDeviceChannelSeq&       inout()    { return *_pd_seq; }
    inline TDeviceChannelSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TDeviceChannelSeq* _retn() { TDeviceChannelSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TDeviceChannelSeq_out;
    
  private:
    TDeviceChannelSeq* _pd_seq;
  };

  class TDeviceChannelSeq_out {
  public:
    inline TDeviceChannelSeq_out(TDeviceChannelSeq*& _s) : _data(_s) { _data = 0; }
    inline TDeviceChannelSeq_out(TDeviceChannelSeq_var& _s)
      : _data(_s._pd_seq) { _s = (TDeviceChannelSeq*) 0; }
    inline TDeviceChannelSeq_out(const TDeviceChannelSeq_out& _s) : _data(_s._data) {}
    inline TDeviceChannelSeq_out& operator = (const TDeviceChannelSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TDeviceChannelSeq_out& operator = (TDeviceChannelSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator TDeviceChannelSeq*&()  { return _data; }
    inline TDeviceChannelSeq*& ptr()       { return _data; }
    inline TDeviceChannelSeq* operator->() { return _data; }

    inline TDeviceChannel& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TDeviceChannelSeq*& _data;

  private:
    TDeviceChannelSeq_out();
    TDeviceChannelSeq_out& operator=(const TDeviceChannelSeq_var&);
  };

  struct TDevice {
    typedef _CORBA_ConstrType_Variable_Var<TDevice> _var_type;

    
    ::CORBA::String_member deviceType;

    ::CORBA::String_member address;

    ::CORBA::UShort moduleNum;

    ::CORBA::String_member deviceID;

    ::CORBA::String_member deviceContext;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef TDevice::_var_type TDevice_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< TDevice,TDevice_var > TDevice_out;

#ifndef __STI__Server__Device_mServerConfigure__
#define __STI__Server__Device_mServerConfigure__

  class ServerConfigure;
  class _objref_ServerConfigure;
  class _impl_ServerConfigure;
  
  typedef _objref_ServerConfigure* ServerConfigure_ptr;
  typedef ServerConfigure_ptr ServerConfigureRef;

  class ServerConfigure_Helper {
  public:
    typedef ServerConfigure_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ServerConfigure, ServerConfigure_Helper> ServerConfigure_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ServerConfigure,ServerConfigure_Helper > ServerConfigure_out;

#endif

  // interface ServerConfigure
  class ServerConfigure {
  public:
    // Declarations for this interface type.
    typedef ServerConfigure_ptr _ptr_type;
    typedef ServerConfigure_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ServerConfigure :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Boolean registerDevice(const char* deviceName, TDevice& device);
    ::CORBA::Boolean setChannels(const char* deviceID, const TDeviceChannelSeq& channels);
    ::CORBA::Boolean activateDevice(const char* deviceID);
    ::CORBA::Boolean removeDevice(const char* deviceID);
    TAttributeSeq* attributes();
    char* serverName();

    inline _objref_ServerConfigure()  { _PR_setobj(0); }  // nil
    _objref_ServerConfigure(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ServerConfigure();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ServerConfigure(const _objref_ServerConfigure&);
    _objref_ServerConfigure& operator = (const _objref_ServerConfigure&);
    // not implemented

    friend class ServerConfigure;
  };

  class _pof_ServerConfigure : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ServerConfigure() : _OMNI_NS(proxyObjectFactory)(ServerConfigure::_PD_repoId) {}
    virtual ~_pof_ServerConfigure();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ServerConfigure :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ServerConfigure();

    virtual ::CORBA::Boolean registerDevice(const char* deviceName, TDevice& device) = 0;
    virtual ::CORBA::Boolean setChannels(const char* deviceID, const TDeviceChannelSeq& channels) = 0;
    virtual ::CORBA::Boolean activateDevice(const char* deviceID) = 0;
    virtual ::CORBA::Boolean removeDevice(const char* deviceID) = 0;
    virtual TAttributeSeq* attributes() = 0;
    virtual char* serverName() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_STI_Server_Device
_CORBA_MODULE_BEG

  class Configure :
    public virtual STI_Server_Device::_impl_Configure,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Configure();

    inline ::STI_Server_Device::Configure_ptr _this() {
      return (::STI_Server_Device::Configure_ptr) _do_this(::STI_Server_Device::Configure::_PD_repoId);
    }
  };

  class DataTransfer :
    public virtual STI_Server_Device::_impl_DataTransfer,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~DataTransfer();

    inline ::STI_Server_Device::DataTransfer_ptr _this() {
      return (::STI_Server_Device::DataTransfer_ptr) _do_this(::STI_Server_Device::DataTransfer::_PD_repoId);
    }
  };

  class DeviceControl :
    public virtual STI_Server_Device::_impl_DeviceControl,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~DeviceControl();

    inline ::STI_Server_Device::DeviceControl_ptr _this() {
      return (::STI_Server_Device::DeviceControl_ptr) _do_this(::STI_Server_Device::DeviceControl::_PD_repoId);
    }
  };

  class ServerConfigure :
    public virtual STI_Server_Device::_impl_ServerConfigure,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ServerConfigure();

    inline ::STI_Server_Device::ServerConfigure_ptr _this() {
      return (::STI_Server_Device::ServerConfigure_ptr) _do_this(::STI_Server_Device::ServerConfigure::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_STI_Server_Device
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(STI_Server_Device::TValue _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Server_Device::TValue& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Server_Device::ValueMeas) {
    _e = (STI_Server_Device::TValue) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI_Server_Device::TData _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Server_Device::TData& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Server_Device::DataNone) {
    _e = (STI_Server_Device::TData) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI_Server_Device::TStatusLevel _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Server_Device::TStatusLevel& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Server_Device::LevelError) {
    _e = (STI_Server_Device::TStatusLevel) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI_Server_Device::TChannelType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI_Server_Device::TChannelType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI_Server_Device::BiDirectional) {
    _e = (STI_Server_Device::TChannelType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}



inline void
STI_Server_Device::Configure::_marshalObjRef(::STI_Server_Device::Configure_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Server_Device::DataTransfer::_marshalObjRef(::STI_Server_Device::DataTransfer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Server_Device::DeviceControl::_marshalObjRef(::STI_Server_Device::DeviceControl_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI_Server_Device::ServerConfigure::_marshalObjRef(::STI_Server_Device::ServerConfigure_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
#endif

#endif  // __device_hh__

